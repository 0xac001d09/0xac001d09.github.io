<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据仓库期末复习, 0xac001d09">
    <meta name="description" content="Keep on keeping on">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>数据仓库期末复习 | 0xac001d09</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">0xac001d09</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">0xac001d09</div>
        <div class="logo-desc">
            
            Keep on keeping on
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://gitee.com/Jerry1997/img-bed/raw/master/uPic/Xnip2020-03-05_22-53-32.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据仓库期末复习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">
                                <span class="chip bg-color">数据仓库</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-category">
                                期末复习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-11-28
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    36 分
                </div>
                

                
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="#jump1">第二章 数据仓库</a></p>
<p><a href="#jump2">第三章 数据预处理</a></p>
<p><a href="#jump3">第四章 特征化和区分</a></p>
<p><a href="#jump4">数据挖掘</a></p>
<p><a href="#jump5">第五章 关联规则挖掘</a></p>
<p><a href="#jump6">第六章 分类挖掘</a></p>
<p><a href="#jump7">第七章 聚类挖掘</a></p>
<h2 id="第二章-数据仓库"><a href="#第二章-数据仓库" class="headerlink" title="第二章 数据仓库"></a><span id="jump1">第二章 数据仓库</span></h2><h3 id="1、B树索引"><a href="#1、B树索引" class="headerlink" title="1、B树索引"></a>1、B树索引</h3><p><strong>考题：为何B树等在数据库中广泛使用的索引技术无法直接被引入数据仓库？</strong></p>
<pre><code>1、B树要求属性必须具有许多不同的值，比如身份证号这种取值字段，取值范围很广，几乎没有重复。
2、B树要求查询应具有更简单的条件和更少的结果
3、创建B树的空间复杂度和时间复杂度很大</code></pre><p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193620991.png" alt=""></p>
<h3 id="2、位图索引-BitMap-Index"><a href="#2、位图索引-BitMap-Index" class="headerlink" title="2、位图索引 BitMap Index"></a>2、位图索引 BitMap Index</h3><p>位图索引分为两种，简单位图索引和编码位图索引，考试时候会让你画简单位图索引。</p>
<h4 id="（1）简单位图索引"><a href="#（1）简单位图索引" class="headerlink" title="（1）简单位图索引"></a>（1）简单位图索引</h4><p>对于每个属性，将属性中的不同取值生成不同的位向量！有几个不同的取值就有几个不同的位向量。如果数据表中某一元组的属性 值为 v，则在位图索引的对应行表示该值的位为 1，该行的其它位为 0。 </p>
<p>例如：<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193733088.png" alt=""></p>
<p>如果我们要找买了b产品的女性，计算时候首先取出b产品和女性F向量做&amp;操作</p>
<blockquote>
<p>b：0 0 1 1 1 0 0 0</p>
<p>F：1 0 1 1 0 1 0 0</p>
<hr>
<pre><code>0 0 1 1 0 0 0 0</code></pre><p>发现第3位和第4位为1，表示第三行、第四行数据是我们要的结果</p>
</blockquote>
<p>位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，对于性别，可取值的范围只有’男’,’女’，并且男和女可能各站该表的50%的数据，这时添加B树索引还是需要取出一半的数据， 因此完全没有必要。如果某个字段的取值范围很广，几乎没有重复，比如身份证号，就不适合用位图索引，适合B树索引。</p>
<h3 id="3、连接索引-Join-Index"><a href="#3、连接索引-Join-Index" class="headerlink" title="3、连接索引 Join Index"></a>3、连接索引 Join Index</h3><p>适用于复杂的查询！复杂的查询往往需要<strong>多表连接</strong>，使用连接索引能提高性能。考试时候要求画出连接索引怎么画？</p>
<p>先说下什么是事实表、维表。事实表就是你要关注的内容，比如各种销售数据，通常包含大量的行。维表就是你观察该事物的角度，你从哪个角度去查看这个内容？比如对于销售数据，可以从某个地区的来看，地区就是维度。</p>
<p>例如，在一个星型模式中，事实表 Sales 与维表 Customer 和 Item 三者之间的链接关系如图所示。</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193749121.png" alt=""></p>
<p>它们的连接索引表如图所示。 </p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193803129.png" alt=""></p>
<h3 id="4、数据仓库存储策略"><a href="#4、数据仓库存储策略" class="headerlink" title="4、数据仓库存储策略"></a>4、数据仓库存储策略</h3><p>在逻辑模型设计的基础上确定数据存储结构、索引策略、存储分配和数据存放位置等与物理有关的内容，与数据库设计中大致相似。</p>
<p>常用技术</p>
<ul>
<li>合并表<br>表的连接操作消耗很多时间，将表合并后存放，可以节约连接的时间，这是以空间换时间的策略</li>
<li>数据序列<br>将连续使用的数据连续存储，原先表示逻辑的部分可以继续存在</li>
<li>引入冗余<br>此处特指将一个属性从一张表扩散到其它表的过程，这个过程中，冗余就可以节约访问的连接次数</li>
<li>表的物理分割<br>类似逻辑设计阶段的数据分割，用拆分的表来表达原有逻辑意义上的一张表</li>
<li>生成导出数据<br>如果某张表的统计数据被频繁访问，这部分聚集数据就可以另行记录</li>
<li>建立广义索引<br>记录与“最”有关的统计结果。这部分数据非常小，又可以在数据刷新阶段直接建立，进行此类查询时就可以将统计操作转换为简单查找<strong>所以不用B树索引！</strong></li>
</ul>
<h3 id="5、数据仓库"><a href="#5、数据仓库" class="headerlink" title="5、数据仓库"></a>5、数据仓库</h3><h4 id="（1）数据仓库的出现？"><a href="#（1）数据仓库的出现？" class="headerlink" title="（1）数据仓库的出现？"></a>（1）数据仓库的出现？</h4><p>建立数据仓库<strong>不是</strong>要替代传统的事务处理系统和数据库，而是在新的领域中更加适应分析型处理的需要。数据仓库正成为信息集成的主要手段之一。</p>
<p>其出现目的：</p>
<ul>
<li>提高两个系统的性能</li>
<li>提高操作性数据库的事务吞吐量</li>
<li>两个系统中的数据结构、内容和用法可以不同</li>
</ul>
<h4 id="（2）数据仓库的特点-特征"><a href="#（2）数据仓库的特点-特征" class="headerlink" title="（2）数据仓库的特点/特征"></a>（2）数据仓库的特点/特征</h4><ul>
<li><p>面向主题</p>
<p>主题就是企业中某一领域涉及到的分析对象，面向主题就是说：数据仓库内的信息是按照主题进行组织的。主题是要经过抽取得出的</p>
</li>
<li><p>集成</p>
<p>全部数据放置在同一个地方，形成完整、一致的数据汇总</p>
</li>
<li><p>非易失</p>
<p>数据仓库的数据与操作型数据环境隔离</p>
</li>
<li><p>时变</p>
<p>数据仓库随时都是一个只读的备份，每隔一段时间完成一次对数据仓库的刷新</p>
</li>
</ul>
<h3 id="6、OLAP"><a href="#6、OLAP" class="headerlink" title="6、OLAP"></a>6、OLAP</h3><p>OLAP即联机分析处理，通过专门的数据综合引擎，辅以更加直观的数据访问界面，在短时间内相应非数据处理专业人员的复杂查询要求。</p>
<h4 id="（1）OLAP特点"><a href="#（1）OLAP特点" class="headerlink" title="（1）OLAP特点"></a>（1）OLAP特点</h4><ul>
<li>OLAP是面向特定问题的联机数据访问和分析<br>OLAP是只读的工具，这是与SQL的巨大差异</li>
<li>通过对信息多种可能的观察形式进行快速、稳定一致和交互性的存取<br>多个“维度”</li>
<li>允许决策人员对数据进行深入观察<br>以人为主导</li>
</ul>
<h4 id="（2）OLAP的基本数据模型"><a href="#（2）OLAP的基本数据模型" class="headerlink" title="（2）OLAP的基本数据模型"></a>（2）OLAP的基本数据模型</h4><ul>
<li><p>MOLAP<br>多维数据库</p>
</li>
<li><p>ROLAP</p>
<p>用事实表的二维模型存放度量值，定义大量外关键字指向维度</p>
<ul>
<li>星形模型</li>
<li>雪花模型</li>
</ul>
</li>
</ul>
<p><strong>详细介绍ROLAP</strong></p>
<ul>
<li><p>星型模式</p>
<ul>
<li>n维的多维表有一个事实表和n个维表增加一个新的维度，就增加一个维表，从而易于扩充</li>
<li>应对多维查询时，依赖标准SQL将事实表与维表进行<strong>连接</strong>与<strong>聚集</strong></li>
<li>星型模式的优势在于架构一旦确定下来，影响架构的宏观因素就很少，可以以<strong>基本固定的方式</strong>进行优化</li>
</ul>
</li>
<li><p>雪花模型</p>
<ul>
<li>对星型模式的扩展<br>某些维表并不是单一的平面结构，所有维属性的地位并不等同</li>
<li>优点<ul>
<li>更加适应人类的理解和观察<br>内在的关联性通过将子维表分列而体现出来</li>
<li>规范化的设计趋势节约存储空间</li>
</ul>
</li>
<li>缺点<ul>
<li>结构远比星型模式复杂</li>
<li>额外进行的多次连接造成性能损失</li>
<li>即使维数相同，表的结构也可能有很大差异<br>难以优化</li>
</ul>
</li>
</ul>
</li>
<li><p>其它扩展模式</p>
<ul>
<li>星座模式<br>通过公共维度连接多个星型模式</li>
<li>雪暴模式<br>通过公共维度连接多个雪花模型</li>
</ul>
</li>
</ul>
<h3 id="7、数据立方体"><a href="#7、数据立方体" class="headerlink" title="7、数据立方体"></a>7、数据立方体</h3><p>数据立方体是一种多维数据模型，主要有星形模式、雪花模式和事实星座模式。</p>
<ul>
<li><p>星形模式<br>它是最常见的模式，它包括一个大的中心表（事实表），包含了大批数据但是不冗余；一组小的附属表（维表），每维一个。如下所示，从item、time、branch、location四个维度去观察数据，中心表是Sales Fact Table，包含了四个维表的标识符（由系统产生）和三个度量。每一维使用一个表表示，表中的属性可能会形成一个层次或格。<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193842012.png" alt=""></p>
</li>
<li><p>雪花模式<br>它是星模式的变种，将其中某些表规范化，把数据进一步的分解到附加的表中，形状类似雪花。 <img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193909415.png" alt=""></p>
</li>
<li><p>事实星座</p>
<p>允许多个事实表共享维表，可以看作是星形模式的汇集。如下所示，Sales和Shipping两个事实表共享了time、item、location三个维表。</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193927337.png" alt=""></p>
</li>
</ul>
<p>在数据仓库中多用事实星座模式，因为它能对多个相关的主题建模；而在数据集市流行用星形或雪花模式</p>
<h3 id="8、多维数据分析手段"><a href="#8、多维数据分析手段" class="headerlink" title="8、多维数据分析手段"></a>8、多维数据分析手段</h3><ul>
<li>切片</li>
</ul>
<p>只看与该维成员相关的数据，就是降维</p>
<ul>
<li>切块</li>
</ul>
<p>可以认为是切片的复合操作，维度可能无法下降，但数据量得以减少</p>
<ul>
<li>旋转</li>
</ul>
<p>交换维度的排列顺序，获取全新的呈现方式。高维的旋转操作会很有用，交换了某些维度的焦点</p>
<ul>
<li>上钻</li>
</ul>
<p>将层次较低的数据集提高层次，上钻不会变更观察的主体</p>
<ul>
<li>下钻</li>
</ul>
<p>上钻的逆操作，降低数据层次，上钻与下钻并不能无限地进行下去，下界为原子层。</p>
<ul>
<li>其它操作<ul>
<li>跨钻<br>同步地对多个多维模型进行上钻或下钻，方便进行多个事实的对比</li>
</ul>
</li>
<li>钻透<ul>
<li>下钻到数据立方体最低细节后，继续细化到数据仓库/数据库的关系型表格</li>
<li>可以发现一些错误</li>
</ul>
</li>
</ul>
<h3 id="9、数据仓库的设计"><a href="#9、数据仓库的设计" class="headerlink" title="9、数据仓库的设计"></a>9、数据仓库的设计</h3><p>见ppt</p>
<h2 id="第三章-数据预处理"><a href="#第三章-数据预处理" class="headerlink" title="第三章 数据预处理"></a><span id="jump2">第三章 数据预处理</span></h2><h3 id="1、数据预处理过程"><a href="#1、数据预处理过程" class="headerlink" title="1、数据预处理过程"></a>1、数据预处理过程</h3><ul>
<li><p>数据清洗</p>
<ul>
<li>缺失值、噪声、非一致</li>
</ul>
</li>
<li><p>数据集成</p>
<ul>
<li>模式集成、发现冗余、数据值冲突检测和处理 </li>
</ul>
</li>
<li><p>数据变换</p>
<ul>
<li>光滑、聚集、泛化、规范化、属性构造 </li>
</ul>
</li>
<li><p>数据规约</p>
<ul>
<li>数据立方体聚集、属性子集选择、维度规约、数值规约、离散化和概念 分层产生 </li>
</ul>
</li>
<li><p>数据离散化</p>
<ul>
<li><p>数值数据</p>
<ul>
<li>分箱、直方图、聚类、基于熵的离散化、基于直观划分离散化 </li>
</ul>
</li>
<li><p>分类数据</p>
<ul>
<li>用户或专家在模式级显示说明属性偏序，层次高，属性值个数越少 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、数据清洗"><a href="#2、数据清洗" class="headerlink" title="2、数据清洗"></a>2、数据清洗</h3><p><strong>噪声数据</strong>：测量变量时出现的随机错误或是差异，出现原因可能是属性值不正确（数据收集工具问题、数据的输入或传输问题等）以及数据不完整、不一致、重复记录产生的</p>
<p><strong>针对噪声数据的处理方法</strong>：分箱/分桶、聚类、人工检查、回归</p>
<p><strong>简单离散化方法：分箱</strong></p>
<ul>
<li>等宽分箱 equip-width<ul>
<li>将范围分为相等大小的N个间隔  </li>
<li>间隔的宽度将为：W =（B-A）/ N  （属性最高值-最低值）/N个间隔</li>
</ul>
</li>
<li>等深分箱 equip-depth<ul>
<li>分成N个间隔，每个间隔样本数相同</li>
</ul>
</li>
</ul>
<p>分箱后需要平滑数据，主要方法有：按箱平均值平滑、按箱中值平滑、按箱边界平滑<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305193950137.png" alt=""></p>
<h3 id="3、数据集成与变换"><a href="#3、数据集成与变换" class="headerlink" title="3、数据集成与变换"></a>3、数据集成与变换</h3><p>数据集成主要讲了去除冗余啥的，这边主要看数据转换的方式</p>
<h4 id="（1）数据变换"><a href="#（1）数据变换" class="headerlink" title="（1）数据变换"></a>（1）数据变换</h4><ul>
<li>平滑<ul>
<li>消除噪声数据</li>
</ul>
</li>
<li>聚合<ul>
<li>汇总数据</li>
</ul>
</li>
<li>泛化<ul>
<li>概念层次爬升，就是概念化</li>
</ul>
</li>
<li><strong>归一化</strong><ul>
<li>缩放数据到指定范围内</li>
</ul>
</li>
<li>属性/特征构造</li>
</ul>
<h4 id="（2）归一化的三种方式"><a href="#（2）归一化的三种方式" class="headerlink" title="（2）归一化的三种方式"></a>（2）归一化的三种方式</h4><ul>
<li><p>min-max normalization</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194007433.png" alt=""></p>
<p>value’ =（value-最小值）/（最大值-最小值）</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194024971.png" alt=""></p>
</li>
<li><p>Z-score normalization </p>
<p>Z标准化也叫标准差标准化，这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194047639.png" alt=""></p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194059338.png" alt=""></p>
</li>
<li><p>normalization by decimal scaling</p>
<p>进制缩放归一化。这种方法通过移动数据的小数点位置来进行标准化。小数点移动多少位取决于属性A的取值中的<strong>最大绝对值</strong>。公式中j是满足条件的最小整数。<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194113774.png" alt=""><br>例如 假定A的值由-986到917，A的最大绝对值为986，为使用小数定标标准化，我们用每个值除以1000（即，j=3），这样，-986被规范化为-0.986。<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194126917.png" alt=""></p>
</li>
</ul>
<h3 id="4、数据规约"><a href="#4、数据规约" class="headerlink" title="4、数据规约"></a>4、数据规约</h3><pre><code> Data Reduction，即数据规约，PPT中提到了4中策略</code></pre><ul>
<li>数据立方体聚合</li>
<li>降维</li>
<li>Numerosity reduction</li>
<li>离散化和概念层次生成</li>
</ul>
<p>观察往年试卷，考过<strong>离散化</strong><br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194146684.png" alt=""><br>         <strong>maxdiff</strong>：先给数据排序，给定β个桶或是分组，相邻数据的最大差是β-1，超过这个最大差就不能放进一个桶。</p>
<p>例子：<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194209620.png" alt=""><br>有个疑惑，最小方差每组算出来为什么要x2？</p>
<p><strong>离散化的其他方法</strong></p>
<ul>
<li><p>基于熵的离散化      Entropy-based discretization  </p>
<p>给定一组样本S，如果使用边界T将S划分为两个区间S1和S2，则划分后的熵为<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194227336.png" alt=""></p>
<p>选择在所有可能的边界上使熵函数最小的边界作为二进制离散化。该过程将递归应用于获得的分区，直到满足某些停止条件为止。<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194245041.png" alt=""></p>
</li>
<li><p>3-4-5规则</p>
<p>3-4-5规则可用于将数字数据分段为相对均匀的“自然”间隔。</p>
<p>看这个<a href="https://blog.csdn.net/weixin_42859280/article/details/93306099" target="_blank" rel="noopener">博客</a>！</p>
<ul>
<li>如果间隔的最高有效位数涵盖3、6、7或9个不同的值，则将范围划分为3个等宽间隔</li>
<li>如果它的最高有效位涵盖2、4或8个不同的值，请将范围划分为4个间隔</li>
<li>如果它的最高有效位涵盖1、5或10个不同的值，请将范围划分为5个间隔</li>
</ul>
</li>
</ul>
<h2 id="第四章-特征化和区分"><a href="#第四章-特征化和区分" class="headerlink" title="第四章 特征化和区分"></a><span id="jump3">第四章 特征化和区分</span></h2><p>废话</p>
<h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a><span id="jump4">数据挖掘</span></h2><h3 id="1、数据挖掘"><a href="#1、数据挖掘" class="headerlink" title="1、数据挖掘"></a>1、数据挖掘</h3><h4 id="（1）数据挖掘是什么？"><a href="#（1）数据挖掘是什么？" class="headerlink" title="（1）数据挖掘是什么？"></a>（1）数据挖掘是什么？</h4><p>数据挖掘=数据库里的知识发现，在大量的、完整的数据中进行挖掘，总结规律、得出知识，来指导客观世界。</p>
<h4 id="（2）数据挖掘基本概念"><a href="#（2）数据挖掘基本概念" class="headerlink" title="（2）数据挖掘基本概念"></a>（2）数据挖掘基本概念</h4><ul>
<li>模式<ul>
<li>任何用高级语言表达一定逻辑含义的信息都是模式（信息+判断）</li>
</ul>
</li>
<li>知识<ul>
<li>满足用户对客观评价标准（支持度/置信度……）和主观评价标准要求的<strong>模式</strong></li>
</ul>
</li>
<li>置信度 condidence<ul>
<li>某个数据集上，模式成立的程度，例如<strong>在购买面包和黄油的顾客中，大部分的人同时也买了牛奶</strong>，该模式的置信度为：同时购买面包、黄油、牛奶的顾客人数占同时购买面包、黄油的顾客人数的百分比。</li>
<li>置信度不是固定的</li>
<li>没有足够的置信度，模式也不能称为知识</li>
</ul>
</li>
<li>支持度 support<ul>
<li>某一数据集上，模式被用户关注的程度，也叫做<strong>兴趣度</strong></li>
</ul>
</li>
<li>非平凡性<ul>
<li>平凡的知识不是数据挖掘的目标，因为这样的知识已经成为<strong>常识</strong>，我们要找的是不平凡的知识</li>
</ul>
</li>
</ul>
<h4 id="（3）数据挖掘和数据仓库啥关系？"><a href="#（3）数据挖掘和数据仓库啥关系？" class="headerlink" title="（3）数据挖掘和数据仓库啥关系？"></a>（3）数据挖掘和数据仓库啥关系？</h4><ul>
<li>数据挖掘原本建立在数据库的基础之上</li>
<li>产生数据仓库技术后<br>由于数据仓库中的数据都是经过抽取、整理和预处理后的综合数据，因而数据挖掘工作可以在数据仓库上直接运行，任务相对来说会简单很多，<em>但并不代表数据挖掘可以无缝地架设在数据仓库之上</em></li>
</ul>
<h4 id="（4）数据挖掘步骤"><a href="#（4）数据挖掘步骤" class="headerlink" title="（4）数据挖掘步骤"></a>（4）数据挖掘步骤</h4><ul>
<li><p>数据的集成</p>
<ul>
<li><p>没数据怎么行？一般都集成到数据仓库</p>
</li>
<li><p>在数据仓库要对数据预处理</p>
<ul>
<li>清洗、集成、转换、减少</li>
</ul>
</li>
</ul>
</li>
<li><p>数据规约</p>
<ul>
<li>用于数据挖掘的数据量非常巨大，数据规约可以减低数据量，提高数据挖掘操作的性能</li>
</ul>
</li>
</ul>
<ul>
<li><p>常见的数据规约技术</p>
<ul>
<li>数据立方体计算</li>
<li>挖掘范围的选择<ul>
<li>在不影响挖掘结果的前提下，尽可能地选取那些与挖掘操作有关的属性集，去除明显无关的因素，或由于法规、风俗等原因，即使有相应的分析结果也无法应用的</li>
<li>时间范围或备份内容上的选择</li>
</ul>
</li>
<li>数据压缩<br>减低数据的规模，节省存储空间开销和数据通讯开销，如果采用的数据挖掘算法不需要解压就可直接对压缩数据进行挖掘，数据压缩技术将非常有用</li>
<li>离散化处理<br>将属性值的连续区域划分为若干个区域，用每个区域的标识代替原来的值，以减低该属性上属性值的个数，也可利用这种数据规约技术来自动地建立该属性的概念层次树</li>
</ul>
</li>
</ul>
<ul>
<li><p>挖掘</p>
<ul>
<li>挖掘方法<ul>
<li>关联规则挖掘–第五章</li>
<li>分类挖掘–第六章</li>
<li>聚类挖掘–第七章</li>
</ul>
</li>
</ul>
</li>
<li><p>表示</p>
<ul>
<li>可以包括文字、图形、表格、图标等可视化形式</li>
</ul>
</li>
</ul>
<h2 id="第五章：关联规则挖掘"><a href="#第五章：关联规则挖掘" class="headerlink" title="第五章：关联规则挖掘"></a><span id="jump5">第五章：关联规则挖掘</span></h2><h3 id="1、关联规则"><a href="#1、关联规则" class="headerlink" title="1、关联规则"></a>1、关联规则</h3><p><a href="https://www.jianshu.com/p/7d459ace31ab" target="_blank" rel="noopener">资料</a></p>
<ul>
<li><p>关联规则用于表示事务数据库中诸多属性之间的关联程度</p>
</li>
<li><p>关联规则挖掘则是利用数据库中的大量数据通过<strong>关联算法</strong>寻找<strong>属性</strong>间的相关性</p>
</li>
<li><p>属性在这里被称为 <strong>项</strong></p>
<p>若干个属性所构成的属性集被称为一个 <strong>项集</strong></p>
<blockquote>
<h6 id="例：超级市场"><a href="#例：超级市场" class="headerlink" title="例：超级市场"></a>例：超级市场</h6><p>在购买商品A的客户中有90%的人会同时购买商品B，则可用关联规则表示为：</p>
<pre><code>R1：A-&gt;B 表示一条规则</code></pre></blockquote>
</li>
<li><p>A-&gt;B与B-&gt;A的支持度是相同的，但置信度通常不同</p>
</li>
<li><p>任意组合均能构成关联规则</p>
<p>为了发现有意义的关联规则，需要给定两个阈值：</p>
<p><strong>最小支持度</strong> 和 <strong>最小置信度</strong></p>
<ul>
<li>满足最小置信度和最小支持度的规则为<strong>强规则</strong>，否则为<strong>弱规则</strong></li>
<li>关联规则挖掘的实质是<strong>在数据库（数据仓库）中寻找强规则</strong></li>
</ul>
</li>
</ul>
<p>支持度：$Sup(X) = \frac{Sum(X)}{N}$</p>
<p>置信度：$Conf(X \to Y) = \frac{Sup(X\cup Y)}{Sup(X)}$</p>
<h3 id="2、Apriori算法"><a href="#2、Apriori算法" class="headerlink" title="2、Apriori算法"></a>2、Apriori算法</h3><p>推荐<a href="https://www.cnblogs.com/en-heng/p/5719101.html" target="_blank" rel="noopener">博客</a></p>
<h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><ul>
<li>项<br>在数据库中出现的属性值，每一个属性值构成一个项</li>
<li>项集<br>在数据库中出现的属性值的集合</li>
<li>k-项集<br>由k个项构成的项集</li>
<li>频繁项集<ul>
<li>该项集在数据库中出现的频度满足用户规定的最小支持度的要求</li>
<li>即<strong>同时含有该项集中的所有属性值的记录数</strong> 占 <strong>所有记录数的百分比</strong> 大于等于用户规定的最小支持度</li>
</ul>
</li>
<li>关联规则一定是在满足用户的最小支持度要求的频繁项集中产生的<ul>
<li><strong>关联规则的挖掘过程也就是在数据库中寻找频繁项集的过程</strong></li>
<li>寻找频繁项集过程中，遵循<strong>每个频繁项集的任一子集也是一个频繁项集</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）寻找频繁项集的方法"><a href="#（2）寻找频繁项集的方法" class="headerlink" title="（2）寻找频繁项集的方法"></a>（2）寻找频繁项集的方法</h5><blockquote>
<ul>
<li>寻找一阶频繁项集C1<br>除去非频繁项集，得到L1</li>
<li>从L1生成二阶超集，即候选频繁项集C2<br>除去非频繁项集，得到L2</li>
<li>从L2生成三阶超集C3<br>除去暂时不需要考虑的更高阶超集<br>除去非频繁项集，得到L3</li>
<li>……</li>
</ul>
<p>最后得到的频繁项集是<strong>L1、L2、L3……的并</strong></p>
</blockquote>
<p>Apriori算法：执行算法之前，用户需要先给定最小的支持度和最小的置信度。生成关联规则一般被划分为如下两个步骤：</p>
<ol>
<li><p>利用最小支持度从数据库中找到频繁项集。</p>
<p>给定一个数据库 D ，寻找频繁项集流程如下图所示<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194319757.png" alt=""></p>
<pre><code>    首先寻找一阶频繁项集C1，C1中，{1}的支持度为2/4 = 0.5（数据库D中一共四条事物，{1}出现在其中的两条事物中），C1中的其他几个也是这么计算的，假设给定的最小支持度 $SUP_{min} = 0.5$，{4}就被排除了，得到L1。

    接下来从L1生成二阶超集，即候选频繁项集C2，除去非频繁项集（也就是低于SUP_min = 0.5的），得到L2。

    从L2生成三阶超集C3，除去暂时不需要考虑的更高阶超集，除去非频繁项集，得到L3

    我们可以看到 itemset 中所包含的 item 是从 1 增长到 3 的。并且每次增长都是利用上一个 itemset 中满足支持度的 item 来生成的，这个过程称之为**候选集生成**</code></pre></li>
<li><p>利用最小置信度从频繁项集中找到关联规则。（3）中内容</p>
<p>同样假定最小的置信度为 0.5 ，从频繁项集 {2 3 5} 中我们可以发现规则 {2 3} ⇒ {5} 的置信度为 1 &gt; 0.5 ，所以我们可以说 {2 3} ⇒ {5} 是一个可能感兴趣的规则。（这里看不懂的话看一下上面置信度公式就懂了）</p>
</li>
</ol>
<p><strong>如何发现全部的频繁项集？</strong></p>
<p>包含N种物品的数据集共有2^N-1种不同的项集，例如包含4种物品的全部项集：<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194340107.png" alt=""></p>
<h5 id="（3）生成关联规则"><a href="#（3）生成关联规则" class="headerlink" title="（3）生成关联规则"></a>（3）生成关联规则</h5><blockquote>
<ul>
<li><p>由此确定关联规则的生成算法：（输入参数：数据集和一个频繁项集）</p>
</li>
<li><p>针对频繁项集{A,C}可以构造两条规则</p>
<pre><code>R1：A-&gt;C
R2：C-&gt;A</code></pre><p>一阶频繁项集无法构造关联规则，只能得到平凡知识<br>将每个频繁项集分为左右两部分，穷举即可以得到</p>
</li>
<li><p>对这些规则进行测试（依次计算置信度，用到的支持度数据在生成频繁项集的时候都存下来了）</p>
</li>
<li><p>通过预先设定的阈值对关联规则进行过滤</p>
</li>
<li><p>合并所有第一个列表中的剩余规则，创建第二个规则列表，其中规则右部包含两个元素</p>
</li>
<li><p>对第二个列表中的规则进行测试</p>
</li>
<li><p>过程重复到N为止（或者无法产生新规则）</p>
</li>
<li><p>最后剩余的关联规则上升为知识，用于决策支持</p>
</li>
</ul>
</blockquote>
<p>比如上面那个例子{2,3,5}，就可以分为 {2}–&gt;{3,5} 与 {2,3}–&gt;{5}，然后计算置信度，也就是</p>
<p>置信度con(X–&gt;Y) = (X U Y)/X。这里有个窍门</p>
<pre><code>假设最小置信度为p，且规则0,1,23并不满足最小置信度要求，即 P(0,1,2,3)/P(0,1,2)&lt;p
那么任何左部为{0,1,2}的子集的规则也不会满足最小置信度要求</code></pre><h5 id="（5）Apriori算法的优化方法"><a href="#（5）Apriori算法的优化方法" class="headerlink" title="（5）Apriori算法的优化方法"></a>（5）Apriori算法的优化方法</h5><p>由于算法是时间开销花在数据库的多次扫描上，主要的优化方法有：</p>
<ul>
<li><p>数据库的划分（Partitioning）方法</p>
<p>针对硬件限制进行优化</p>
<p>虽然置信度和支持度指标可能有变化，但</p>
<p>所有关联规则一定都会出现在各个划分中</p>
<p>划分可能导致产生的关联规则数量过大，提高阈值又会损失原有的规则</p>
<ul>
<li>每一部分都能全部放在内存中进行扫描</li>
<li>最后对得到的所有频繁项集进行归并</li>
</ul>
</li>
<li><p>利用Hash方法筛选2阶频繁项集<br>将每个项哈希到哈希表里，从而大量地过滤不需要的候选集</p>
</li>
<li><p>利用采样数据集得到可能成立的规则，再利用数据库中的剩余数据验证这些规则的正确性<br>由于无法保证结论的正确性，此方式未必靠谱</p>
</li>
<li><p>减少每一遍扫描所处理的记录数</p>
<pre><code>如果一条记录不含有长度为k的频繁项集，那么这条记录也不可能含有长度为(k+1)的频繁项集</code></pre><p>得到所有k阶频繁项集后，以后的每次扫描就不必再访问上述的记录，从而逐步减少被扫描的记录数</p>
</li>
</ul>
<h3 id="3、FP-Growth算法"><a href="#3、FP-Growth算法" class="headerlink" title="3、FP-Growth算法"></a>3、FP-Growth算法</h3><h4 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p><strong>FP核心</strong>：利用FP树递归地增长频繁模式路径（分治）</p>
<p><strong>FP优点</strong>：去除了不相关的信息；出去节点连接和计数规模比原数据库小；快速；将发现长频繁模式的问题转换成递归地搜索一些较短的模式。</p>
<p>关联分析算法，它采取如下分治策略：将提供频繁项集的数据库压缩到一棵频繁模式树（FP-Tree），但仍保留项集关联信息；该算法和Apriori算法最大的不同有两点：第一，<strong>发现频繁项集而不产生候选</strong>  ，第二，只需要两次遍历数据库，大大提高了效率。但是FP-Growth算法只能用来发现频繁项集，不能用来发现关联规则。</p>
<h4 id="（2）算法伪代码"><a href="#（2）算法伪代码" class="headerlink" title="（2）算法伪代码"></a>（2）算法伪代码</h4><p>详细见<a href="http://blog.csdn.net/sealyao/article/details/6460578" target="_blank" rel="noopener">博客</a></p>
<h4 id="（3）PPT例子"><a href="#（3）PPT例子" class="headerlink" title="（3）PPT例子"></a>（3）PPT例子</h4><p><a href="https://blog.csdn.net/weixin_30347335/article/details/97523472" target="_blank" rel="noopener">博客</a></p>
<p>给定数据库D以及min_sup</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194406301.png" alt=""></p>
<ol>
<li><p><strong>FP-Tree构建——第一步</strong></p>
<p>第一步：扫描数据库，得到一阶频繁项集。由于min_sup = 0.5，所以至少出现3次，低于3次的直接不考虑了，得到项集如下</p>
</li>
</ol>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194419583.png" alt=""></p>
<ol start="2">
<li><p><strong>FP-Tree构建——第二步</strong></p>
<p>第二步：以频率递减的顺序对频繁项进行排序，注意里面的顺序<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194436052.png" alt=""></p>
</li>
<li><p><strong>FP-Tree构建——第三步</strong></p>
<p>每个事务中的数据项按降序依次插入到一棵以NULL为根结点的树中，这样所有的ordered frequent items都保存在了树中。，排序靠前的节点是祖先节点，而靠后的是子孙节点。如果有共用的祖先，则对应的公用祖先节点计数加1。插入后，如果有新节点出现，则项头表对应的节点会通过节点链表链接上新节点。直到所有的数据都插入到FP树后，FP树的建立完成。<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194453866.png" alt=""></p>
</li>
<li><p><strong>FP-Tree挖掘——第一步</strong></p>
<pre><code> 得到了FP树和项头表以及节点链表，我们首先要从项头表的底部项依次向上挖掘。对于项头表对应于FP树的每一项，我们要找到它的条件模式基。条件模式基是以我们要挖掘的节点作为叶子节点所对应的FP子树。得到这个FP子树，我们将子树中每个节点的的计数设置为叶子节点的计数，并删除计数低于支持度的节点。从这个条件模式基，我们就可以递归挖掘得到频繁项集了。</code></pre></li>
</ol>
<p>   <img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194532928.png" alt=""><br>   意思是item是x的时候，也就是后缀是x，他的前缀有哪些？出现次数是多少个。比如后缀是c，前缀是f，出现了3次；再比如后缀是b的，他的前缀有fca（1次），f（1次），c（1次），就这个意思</p>
<ol start="5">
<li><p><strong>FP-Tree挖掘——第二步</strong></p>
<p>将得到的FP子树的每个节点的计数设置为叶子节点的而计数，并删除计数低于支持度<strong>（这里至少是3）</strong>的节点。我们就可以得到频繁项集。</p>
<p>一定要看这个<a href="https://blog.csdn.net/weixin_30347335/article/details/97523472" target="_blank" rel="noopener">例子</a><br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194549267.png" alt=""></p>
<p><strong>举例叶子结点是一阶的情况</strong></p>
<p>从底向上挖掘。先看p，它的频繁项集为{f:2,c:3,a:2,m:2,b:1,p:3}、前面5个代表条件模式基（大白话就是每个出现了几次，比如c出现了2+1次）,f、a、m、b的个数低于3个，低于我们要求的支持度，删除，合并一下，得到p结点的频繁二项集{c:3,p:3}，p对应的最大的频繁项集为频繁二项集。</p>
<p>再看m，它的频繁项集为f:3,c:3,a:3,b:1,m:3}，删除b，得到m的频繁四项集{f:3,c:3,a:3m:3}</p>
<p>再看b，它的频繁项集为{f:2,c:2,a:1,b:3}，删除fca，他只是个平凡知识，empty</p>
<p>再看a，它的频繁项集为{f:3,c:3,a:3}，这就是它的三阶频繁项集</p>
<p>再看c，…..</p>
<p><em>老师举的例子</em>（一阶）<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194602041.png" alt=""></p>
<p>一阶结果，明显和我们刚才做的思路结果一致<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194615620.png" alt=""></p>
<p><strong>举例叶子结点是二阶及以上的情况，同样思路</strong><br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194633276.png" alt=""></p>
</li>
</ol>
<h2 id="第六章：分类挖掘"><a href="#第六章：分类挖掘" class="headerlink" title="第六章：分类挖掘"></a><span id="jump6">第六章：分类挖掘</span></h2><h3 id="1、数据分类"><a href="#1、数据分类" class="headerlink" title="1、数据分类"></a>1、数据分类</h3><ul>
<li>通过分析训练数据样本，产生关于类别的精确描述</li>
<li>这种类别通常由分类规则组成，可以用来对未来的数据进行分类和预测</li>
</ul>
<p>首先为每一个数据（记录）打上一个标记，即按标记对数据（记录）进行分类，而分类分析则是对每类数据（具有相同标记的一组记录）找出其固有的特征与规律。</p>
<h3 id="2、数据分类的步骤"><a href="#2、数据分类的步骤" class="headerlink" title="2、数据分类的步骤"></a>2、数据分类的步骤</h3><p>建立一个模型，描述给定的数据类集或概念集，通过分析由属性描述的数据库元组来构造模型</p>
<ul>
<li>用于建立模型的元组集称为训练数据集，其中每个元组成为训练样本<br>训练样本的性质与待分析样本本质上没有差别，都是在实际环境中累积得到的数据</li>
<li>每个训练样本属于一个预定义的类，由类标号属性确定</li>
<li>由于给出了类标号属性，因此该步骤又成为有指导的学习<br>需要知道分类的数量，与对应分类对人来说的意义<br><em>如果训练样本的类标号是未知的，则称为<strong>**无指导的学习（聚类）\</strong></em></li>
<li>学习模型可以用分类规则、决策树和数学公式的形式给出</li>
</ul>
<p><strong>使用模型对数据进行分类</strong></p>
<ul>
<li>评估模型的分类准确性<br>训练数据和测试数据性质应当是一样的，但不能是两份相同的数据<br>评价的标准包括正确性、效率、可理解性</li>
<li>对类标号未知的元组按模型进行分类</li>
</ul>
<h3 id="3、分类分析方法"><a href="#3、分类分析方法" class="headerlink" title="3、分类分析方法"></a>3、分类分析方法</h3><p>是一种特征归纳的方法，将每类数据共有的特性抽取以获得规律性的规则，目前有很多分析方法，<strong>看了下往年试卷就考了决策树和朴素贝叶斯</strong></p>
<ul>
<li>决策树——考试考ID3</li>
<li>朴素贝叶斯<ul>
<li>通过前验概率和后验概率，决定某一特定样本属于标签中某一分类的概率<br>概率的值根据训练样本提供</li>
<li>贝叶斯方法得到的结果不唯一，并且能提供相应结果的概率大小</li>
<li>贝叶斯方法计算复杂<br>在各属性独立时，贝叶斯方法的计算可以简化</li>
</ul>
</li>
</ul>
<p>以上两种方法基于信息论，具有很好的<strong>可剪枝性</strong></p>
<p>K邻近算法也考了。。。不难，看一下就好。</p>
<h3 id="4、决策树——ID3算法"><a href="#4、决策树——ID3算法" class="headerlink" title="4、决策树——ID3算法"></a>4、决策树——ID3算法</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>又称为判定树，是运用于分类的一种树结构</p>
<ul>
<li><p>根据对一个判定进行拆分，连接到下一个判定或结论，构成的关系就是一棵决策树</p>
</li>
<li><p>每个内部结点代表对某个属性的一次测试</p>
</li>
<li><p>每条边代表一个测试结果</p>
</li>
<li><p>叶结点代表某个类或者类的分布</p>
</li>
<li><p>最上面的结点是根结点</p>
</li>
<li><p>通过对信息量的计算，判断每个属性对分类所作判断的贡献大小<br>将一个集合S拆分为S1和S2，其信息量大小有以下关系：</p>
<pre><code>I(S)≥I(S1)+I(S2)
（在属性对分类不起任何作用时取等号）
属性的信息增益A=I(S)-[I(S1)+I(S2)]</code></pre><p>将贡献最优的属性放在顶层，迭代进行</p>
<ul>
<li>中止条件<ul>
<li>训练数据集为空</li>
<li>分类已经确定<br>I(S)=0</li>
<li>属性已经用完，仍然无法确定地分类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（2）ID3算法"><a href="#（2）ID3算法" class="headerlink" title="（2）ID3算法"></a>（2）ID3算法</h4><p>推荐<a href="https://blog.csdn.net/qq_28697571/article/details/84678889" target="_blank" rel="noopener">博客</a></p>
<p>一种基于决策树的算法，根据信息增益，自顶向下贪心建树，信息增益用于度量某个属性对样本集合分类的好坏程度，我们要选择具有最高信息增益的属性。基于训练对象和已知类标号创建决策树，以信息增益为度量来为属性排序。</p>
<p>两个类标记：P（假设有p个元素） 和 N（假设有n个元素），用来判断任一元素属于P还是N的信息量为：<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194652192.png" alt=""><br>根据属性A将集合S划分为集合{S1，S2，…，Sv}，在每个Si中，属于类P的元素为Pi，属于N的元素为ni，用来区分的信息量（熵）为<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194704301.png" alt=""></p>
<p>计算属性A的信息增益 Gain(A)<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194715517.png" alt=""><br><strong>直接看PPT例子</strong></p>
<p>给了这个一张表，按照哪个属性来分类？</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194737187.png" alt=""><br>这个例子中</p>
<blockquote>
<ul>
<li><p>P：buys_computer = “yes” ,N:：buys_computer = “no”,一个14个数据,p:9个，n:5个</p>
</li>
<li><p>I(p, n) = I(9, 5) =0.940</p>
</li>
<li><p>age属性的熵的计算</p>
<ul>
<li>根据age属性，把整个输入集S划分成了三部分：&lt;=30岁，31～40岁，&gt;40岁</li>
<li>&lt;=30岁的5人中，yes 2人，no 3人，那就是 5/14*I(2,3)</li>
<li>31~40岁的4人中，yes 4人，no 0人，那就是 4/14*I(4,0)</li>
<li>大于40岁的5人中，yes 3人，no 2人，那就是5/14*I(3,2)</li>
<li>求和可得age属性的熵E(age)</li>
</ul>
</li>
<li><p>Gain(age) = I(9,5) - E(age)</p>
</li>
<li><p>按照同样的方法求Gain(income)、Gain(student)、Gain(credit_rating)</p>
</li>
</ul>
</blockquote>
<p>结果$Gain(age) = 0.25 &gt; Gain(student) &gt; Gain(credit_rating) &gt; Gain(income)$<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194752584.png" alt=""></p>
<p>这样就知道哪个属性的排序了，然后对age分类下的三种情况</p>
<ul>
<li>在&lt;30情况下，计算信息增益，发现student的信息增益最大，则将student设为节点；</li>
<li>在30-40之间只有yes，所以不需要计算</li>
<li>在&gt;40情况下，发现credit rating的信息增益最大，则设它为节点。</li>
</ul>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194819484.png" alt=""></p>
<h3 id="5、朴素贝叶斯"><a href="#5、朴素贝叶斯" class="headerlink" title="5、朴素贝叶斯"></a>5、朴素贝叶斯</h3><p>朴素贝叶斯算法的数学基础都是围绕贝叶斯定理展开的，因此这一类算法都被称为朴素贝叶斯算法。分类原理是通过对象的先验概率，利用贝叶斯公式计算出后验概率，即对象属于某一类的概率，选择具有后验概率最大的类作为该对象所属的类。下面是贝叶斯公式，要使P(C|X)最大（先验概率），则要使得P(X|C)·P(C)最大（后验概率），</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194834849.png" alt=""></p>
<p>朴素贝叶斯就是假设属性是独立的情况，特征（属性）之间互相独立</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194856094.png" alt=""></p>
<p><strong>例1</strong><br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194913954.png" alt=""></p>
<p>网球比赛示例，p代表能进行比赛，n代表不能进行比赛，X = &lt;rain, hot, high, false&gt;</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305194946881.png" alt=""></p>
<p><strong>例2：贝叶斯信念网络/概率网络</strong></p>
<p>就是将贝叶斯推理与属性之间的因果关系相结合</p>
<p>PPT上例题直接看这<a href="https://blog.csdn.net/qq_36739040/article/details/102652763" target="_blank" rel="noopener">博客</a></p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195004894.png" alt=""></p>
<p><strong>首先计算患心脏病的先验概率</strong></p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195024277.png" alt=""></p>
<blockquote>
<p>α：E的可能取值，β：D的可能取值</p>
<p>由于朴素贝叶斯假设属性之间的独立，即E与D独立，则：P(E=α,D=β) = P(E=α) * P(D=β)</p>
<p>那就是四种情况加起来，PPT顺序错了</p>
</blockquote>
<p>用了这些数据</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195045932.png" alt=""></p>
<pre><code>     结论：不得心脏病的概率更大</code></pre><p><strong>BP=high的情况下，利用同样方法计算高血压数据，它与HD有关</strong></p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195105401.png" alt=""></p>
<p>结论：如果血压高，得心脏病概率更大</p>
<p><strong>在BP=high,D=healthy,E=yes的情况下HD的概率（血压高，饮食健康，做运动的心脏病的概率）</strong><br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195120967.png" alt=""></p>
<h2 id="第七章：聚类挖掘"><a href="#第七章：聚类挖掘" class="headerlink" title="第七章：聚类挖掘"></a><span id="jump7">第七章：聚类挖掘</span></h2><h3 id="1、聚类分析"><a href="#1、聚类分析" class="headerlink" title="1、聚类分析"></a>1、聚类分析</h3><p>聚类分析是在数据中发现数据对象之间的关系，将数据进行分组，组内的相似性越大，组间的差别越大，则聚类效果越好。</p>
<ul>
<li>又称集群分析，它是研究分类问题的一种多元统计方法</li>
<li>分为<strong>距离聚类</strong>和<strong>相似系数聚类</strong>，即定义相似程度的两种方式，实际上没必要严格地区分</li>
<li>没有筛选出一小部分数据，经过处理得到模型，再以此模型进行通用处理的两个阶段</li>
</ul>
<p><strong>与分类分析的混合使用</strong></p>
<p>由于聚类分析的时间复杂度与整体样本数量有关，因此可以抽样一部分数据进行聚类分析，得到结果后，对每个聚类进行概念规则挖掘，人为确定一些概念规则，再以此规则对剩余数据进行分类</p>
<ul>
<li>聚类分析输入的是没有被标记的记录，系统按照一定的规则合理的划分记录集合<br>相当于给记录打标记，但分类标准不是用户确定的</li>
<li>然后采用分类方法对数据进行分析，并根据分析结果重新对原来的记录集合进行划分，进而再进行一次分类分析</li>
<li>如此循环往复，直到获得满意的分析结果</li>
</ul>
<h3 id="2、主要的聚类方法"><a href="#2、主要的聚类方法" class="headerlink" title="2、主要的聚类方法"></a>2、主要的聚类方法</h3><ul>
<li><p>基于划分方法</p>
<p>一些场景中，划分聚类的数量k是知道的；即使不知道划分聚类的数量，也是可以以穷举的方法进行确定的（1≤k≤N）</p>
<ul>
<li>随机地选择k个数据</li>
<li>将其它所有数据打上距离最近的标记<br>完成一次迭代</li>
<li>根据当前聚类选择一个实际（或虚拟）的数据点<br>具有代表性的</li>
<li>第二次迭代，根据选择的点再进行一次划分<br>代表性的数据点继续发生变化</li>
<li>如此循环往复，直到每个数据的聚类不再发生变化为止</li>
<li>代表数据点的选择问题<ul>
<li>如果选择实际的数据点作为代表，选择的标准难以确定</li>
<li>如果选择虚拟的数据点作为代表，数据点又可能没有意义,需要根据实际任务选择类型</li>
</ul>
</li>
</ul>
</li>
<li><p>基于层次的方法</p>
<p>将相似程度最大的两个数据合并，以一个虚拟数据点作为其代表，重复进行计算</p>
<ul>
<li>k值是可以不必给定的<br>以聚类内的相似程度和聚类间的相异程度作为指标</li>
<li>没有迭代的过程，结果可能并不精确</li>
</ul>
</li>
</ul>
<p>ps：往年考了<strong>K-means算法</strong>和 <strong>凝聚式层次式距离算法</strong></p>
<h3 id="3、K-means聚类算法"><a href="#3、K-means聚类算法" class="headerlink" title="3、K-means聚类算法"></a>3、K-means聚类算法</h3><p>这是一种基于划分的距离技术，它将各个聚类子集内的所有数据样本的均值作为该聚类的代表点，算法的主要思想是通过迭代过程把数据集划分为不同的类别，从而使生成的每个聚类内紧凑，类间独立。</p>
<p>考试会出现的距离主要是曼哈顿距离<br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195142265.png" alt=""></p>
<pre><code>k-means算法
输入：簇的数目k和包含n个对象的数据库。
输出：k个簇，使平方误差准则最小。
算法步骤： 
  1.为每个聚类确定一个初始聚类中心，这样就有 K 个初始聚类中心。 
  2.将样本集中的样本按照最小距离原则分配到最邻近聚类  
  3.使用每个聚类中的样本均值作为新的聚类中心。
  4.重复步骤2.3直到聚类中心不再变化。
  5.结束，得到K个聚类</code></pre><p><strong>面向考题学习【2012期末】</strong></p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195201935.png" alt=""></p>
<p><strong>第一个问题：要求给出相异矩阵</strong>，相异度矩阵（存储n个对象两两之间的近似性）。同时，也提出了一个表示n个对象的矩阵，即数据矩阵（用p个变量来表示n个对象），如下图。</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195216105.png" alt=""></p>
<p>我们只需要把每一元组的x、y值带进曼哈顿距离算一下就是答案了-_-</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195230698.png" alt=""></p>
<p><strong>第二个问题：对数据集进行聚类</strong>，给定了簇的数量为k = 3，给定了三个起始中心点（3，5）、（2，6）、（3，8），一共12个点（对象），那么对于剩余的9个点（对象），根据其与各个簇中心的距离，将它赋给最近的簇。大白话就是对剩下的点，用曼哈顿距离算一下它和哪个中心点近，就把它归类过去。</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195245702.png" alt=""></p>
<p>就看前三列，取最小的放入对应聚类</p>
<pre><code>(1,4,6,7,11,12)
(2,9)
(3,5,8,10)</code></pre><p>重新调整三个聚类的中心点</p>
<pre><code>(1,4,6,7,11,12)    --&gt; x = (3+3+4+9+5+4)/6 = 4.6;y = (5+4+5+1+2+2)/6 = 3.17    (4.6,3.17)
(2,9) --&gt; x = (2+1)/2 = 1.5;y = (6+6)/2 = 6 (1.5,6)
(3,5,8,10) x = (3+7+4+6)/4 = 5;y=(8+7+10+8)/4 = 8.25 (5,8.25)</code></pre><p>然后再每个点算到三个中心点的距离，得到三个聚簇</p>
<p>一直这么算直到聚簇内不变化</p>
<h3 id="4、凝聚式层次式距离算法"><a href="#4、凝聚式层次式距离算法" class="headerlink" title="4、凝聚式层次式距离算法"></a>4、凝聚式层次式距离算法</h3><p>【2014期末】b问</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195313654.png" alt=""><br><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195330066.png" alt=""></p>
<p>把每个点与其他点的距离都算出来，选距离最小的作为初始的那两个点，聚到一起之后算它们的中心点，然后这个中心点和其他n-2个点再算距离，再挑出两个最小的聚到一起，再算中心点…..一直到所有的都聚进来。最后我们想要聚成几类就在倒数第几步砍一刀。比如要求聚成两类，在step3砍一刀，一类是cde，另一类是ab。</p>
<p>初始a问曼哈顿距离</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195346521.png" alt=""></p>
<p>聚1和3，再计算其他点到新点距离</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195405686.png" alt=""></p>
<p>聚135，再计算其他点到新点距离</p>
<p><img src="https://gitee.com/Jerry1997/img-bed/raw/master/uPic/image-20200305195423558.png" alt=""></p>
<p>聚1352，最后聚成12345</p>
<p>Ps：凝聚式层次式距离算法倒数第二步应该是聚45，写错了</p>
<p>完结撒花，希望有帮助到你。</p>

            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/">
                                    <span class="chip bg-color">数据仓库</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,wechat,weibo,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/12/02/%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                    <div class="card-image">
                        
                        <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gccf0006itj31em0u0wh1.jpg" class="responsive-img" alt="算法-动态规划">
                        
                        <span class="card-title">算法-动态规划</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            动态规划解题模版：：坐标型坐标型dp一般都是给定网格、序列，来求满足某种性质的最大值、最小值。开数组时，f[i]代表以ai 结尾的满足条件的子序列，f[i][j]代表以i、j结尾的满足条件的某种情况。
做题思路：

从最后一步出发思考，确定
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-12-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                        <span class="chip bg-color">动态规划</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/11/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A4%96%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">
                    <div class="card-image">
                        
                        <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gccezxpla8j31fb0u0aeu.jpg" class="responsive-img" alt="海量数据处理">
                        
                        <span class="card-title">海量数据处理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            海量数据处理（4）：外排序算法一、外排序算法外排序算法是指能够处理极大量数据的排序算法。通常来说，外排序处理的数据不能一次装入内存，只能放在硬盘上。通常采用排序–归并的策略，将原本的大文件，拆分为若干个小文件，小文件可以读入内存中进行排序，
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-11-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" class="post-category">
                                    海量数据处理
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">
                        <span class="chip bg-color">海量数据处理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('100')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 0xac001d09<br />'
            + '文章作者: Jerry<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://0xac001d09.github.io" target="_blank">Jerry</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">106.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/0xac001d09" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:876774731@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=876774731" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 876774731" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
