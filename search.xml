<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法-树状数组</title>
      <link href="/2019/12/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="一、树状数组概念"><a href="#一、树状数组概念" class="headerlink" title="一、树状数组概念"></a>一、树状数组概念</h2><p><strong>Binary Indexed Tree</strong>，用于维护前缀信息的结构，对前缀信息处理也十分高校，用于解决前缀信息问题和区间类问题。</p><p>比如：给定一个数组，实现两个函数</p><ul><li><strong>update</strong>(int index,int val)，将数组下标为index的元素改为val</li><li><strong>querySum</strong>(int start,int end)，返回区间内元素和</li></ul><p>这两个用线段树求过很多遍了。树状数组也是通过前缀和的思想来完成单点更新和区间查询。它比线段树用的空间更小，速度更快。</p><h2 id="二、树状数组算法分析"><a href="#二、树状数组算法分析" class="headerlink" title="二、树状数组算法分析"></a>二、树状数组算法分析</h2><p><strong>注意</strong>：树状数组的下标从 1 开始计数。定义数组 C 是一个对原始数组 A 的预处理数组。</p><p>由原数组构造树状数组</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y3FydTNlajMyNHYwdTAwencuanBn?x-oss-process=image/format,png" alt="image-20200109002039119"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y2xsdzllajMyMXAwdTBnc20uanBn?x-oss-process=image/format,png" alt="image-20200109002054068"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y25uMDE3ajMyMTYwdTBuM3QuanBn?x-oss-process=image/format,png" alt="image-20200109002106786"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y3B3amg0ajMyM3MwdTAwenkuanBn?x-oss-process=image/format,png" alt="image-20200109002127369"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y3BjcXV6ajMyZjgwcXN0ZGguanBn?x-oss-process=image/format,png" alt="image-20200109002400400"></p><blockquote><p><strong>结论</strong>：C[i]来自几个数组A中的元素:取决于i的二进制末尾有几个连续的0。比 如有k个0，那么C[i]来自2^k^个A中的元素。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y29mbGhrajMyM2IwdTBxYXYuanBn?x-oss-process=image/format,png" alt="image-20200109002521025"></p><p>如果i是当前位置，当前有 $2^k$ 个来自A中的元素，有哪 $2^k$ 个呢？就是从C[i]的正下方出发，往前数 $2^k$ 个，C[i]就是这2^k^个数的和。</p><p>定义一个 $lowbit(i) = 2^k$ 函数，就是把下标i传到函数中来，返回 $2^k$，lowbit表示C[i]这个数值是由A中的多少个元素相加得来的。（根据上面一段，你还能找到这几个元素是啥，从C[i]的正下方开始往前数2^k^个）</p><p>怎么找父亲节点？<code>i+lowbit(i) = 父亲</code>比如C[4]，4的lowbit是4，它有个宽度为4的梯子，这个梯子就是它到它父亲的距离宽度。4+lowbit(4) = 8。再比如6，6的lowbit是2，6+2 = 8</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y3I3cWluajMyYXkwcmc0MmsuanBn?x-oss-process=image/format,png" alt="image-20200109003719649"></p><h2 id="三、lowbit函数"><a href="#三、lowbit函数" class="headerlink" title="三、lowbit函数"></a>三、lowbit函数</h2><p>lowbit函数用到了补码相关知识。给定一个数，比如12，我们能求得它的二进制1100，如何求-12的二进制？实际上二进制前面有个符号位，正数前面符号位是0，负数前面符号位是1，12的二进制实际上是01100，那么求-12的二进制有两步</p><ul><li>首先把符号位从0改成1，然后对12每位取反。变成10011</li><li>最后+1，即10011+1 = 10100，这就是-12的二进制</li></ul><p>推荐<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html" target="_blank" rel="noopener">一篇关于原码、反码、补码博客</a></p><p><code>lowbit(i) = 2^k</code>，它就是利用了正数和负数的二进制</p><pre class=" language-java"><code class="language-java">num <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>num<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">^</span>k</code></pre><h2 id="四、树状数组的构建、修改、查询"><a href="#四、树状数组的构建、修改、查询" class="headerlink" title="四、树状数组的构建、修改、查询"></a>四、树状数组的构建、修改、查询</h2><h3 id="1、构建"><a href="#1、构建" class="headerlink" title="1、构建"></a>1、构建</h3><p>把原始数组A和预处理数组C都初始化为0，每更新一个元素，都要把它的值累加到它父亲的值上面去。比如初始化A1后，要把它的值累加到它父亲C1上面去，C1接收到值后，还要把C1的值传递给C2，然后C2传递给C4，C4传递给C8，如果A1的值为10，那第一次更新完就是这个样子</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y2x2ZGZvajMxbjYwamtqdDYuanBn?x-oss-process=image/format,png" alt="image-20200109125400938"></p><p>再更新A2，C2就要开始累加A2的值，并传给C2的父亲们，比如A2为5，就是下面这样子</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXE5Y296c3JsajMxbW8wanEwdjEuanBn?x-oss-process=image/format,png" alt="image-20200109125651336"></p><h3 id="2、更新"><a href="#2、更新" class="headerlink" title="2、更新"></a>2、更新</h3><p>比如我要把A1从10改为1，那么就会有一个差值delta为9，C1更新成1，然后不断传给它的父亲们继续更新。</p><h3 id="3、查询"><a href="#3、查询" class="headerlink" title="3、查询"></a>3、查询</h3><p>想要查询区间<code>[i,j]</code>的和，首先要查询区间<code>[1,j]</code>（树状数组起点从1开始的）和区间<code>[1,i-1]</code>的和，前者减去后者就是我们要求的答案。</p><p>这里还有个求前缀和<code>[1,i]</code>的公式，是推导出来的，<code>sum(i) = sum(i - lowbit(i)) + C[i]</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BinaryIndexedTree</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> C<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义原始数组A和预处理数组C</span>        <span class="token comment" spellcheck="true">//init</span>        <span class="token keyword">public</span> <span class="token function">BinaryIndexedTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            C <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> delta <span class="token operator">=</span> val <span class="token operator">-</span> A<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//得到新val与原val的差值</span>            A<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * 从index+1开始，因为C数组我们定义从1开始的。             * 每次更新完C[index+1]，还要再继续更新它的父亲。距离就是宽度lowbit(i)             */</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> delta<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySum</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">getPrefixSum</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getPrefixSum</span><span class="token punctuation">(</span>start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//获取前缀和</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPrefixSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * 从正下方开始，先找到它前面2^k个的和,比如6，就是找到它前两个（包括它自身）             * i = i - lowbit(i)意思是，找完那2^k个，下一个应该从C[4]开始找了             */</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">-=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> index <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-线段树</title>
      <link href="/2019/12/12/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/12/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>概念：线段树就是一棵二叉树，每个节点代表一个区间，主要用于解决区间类问题。每个节点的属性根据需要可以去自定义，比如节点的属性可以是区间和、区间最大/最小值。。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXBrZWZ3eGthajMxZ2cwaXFkZ24uanBn?x-oss-process=image/format,png" alt="线段树"></p><h2 id="一、线段树节点定义"><a href="#一、线段树节点定义" class="headerlink" title="一、线段树节点定义"></a>一、线段树节点定义</h2><p>每个node有区间的左右端点，以及左右孩子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> start<span class="token punctuation">,</span>end<span class="token punctuation">,</span>val<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//val根据需要定义，比如我定义为区间最大值就是max</span>      SegmentTreeNode left<span class="token punctuation">,</span>right<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token function">SegmentTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="二、线段树的构建、修改、查询"><a href="#二、线段树的构建、修改、查询" class="headerlink" title="二、线段树的构建、修改、查询"></a>二、线段树的构建、修改、查询</h2><h3 id="1、构建"><a href="#1、构建" class="headerlink" title="1、构建"></a>1、构建</h3><p>自上而下，分治法，递归调用。</p><p>对于区间[m1,m2]，mid = (m1+m2)/2，其左儿子区间是[m1,mid]，右儿子区间是(mid+1,m2)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//线段树的构建,以求区间最大值为例,返回根节点</span><span class="token keyword">public</span> SegmentTreeNode <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//先new根区间,根区间最大值暂时为A[start],不能为其他乱七八糟的值比如-1这种...</span>    SegmentTreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//改root的val</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>max <span class="token operator">></span> root<span class="token punctuation">.</span>max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root<span class="token punctuation">.</span>max <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>max <span class="token operator">></span> root<span class="token punctuation">.</span>max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root<span class="token punctuation">.</span>max <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2、修改"><a href="#2、修改" class="headerlink" title="2、修改"></a>2、修改</h3><p>递归调用，一路向下找到最小区间，触底反弹的时候才去修改node。比如数组[6,3,5,1,9]，我要修改1位置上的3，那就是一路向下先找到3，然后返回途中修改 ，时间复杂度logN</p><p><img src="https://img-blog.csdnimg.cn/2020010823242568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="线段树的修改"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//线段树的修改,</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span>SegmentTreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>start <span class="token operator">==</span> index <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>end <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root<span class="token punctuation">.</span>max <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>start <span class="token operator">+</span> root<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//看index在左区间还是右区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>start <span class="token operator">&lt;=</span> index <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">modify</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> index <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">modify</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最后改下根</span>    root<span class="token punctuation">.</span>max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>max<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3、查询"><a href="#3、查询" class="headerlink" title="3、查询"></a>3、查询</h3><p>比如上面例子，找[0,3]，先找[0,2]，再找[3,3]。找[0,2]，直接返回，找[3-3]，就需要走到底</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//线段树的查询</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>SegmentTreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> root<span class="token punctuation">.</span>start <span class="token operator">&amp;&amp;</span> end <span class="token operator">==</span> root<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> root<span class="token punctuation">.</span>max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>start <span class="token operator">+</span> root<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left_max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">int</span> right_max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//求左边最大值</span>    <span class="token comment" spellcheck="true">//如果给定查询范围起点在左子树</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//但是终点在右子树（横跨左子树和右子树）,那么左边最大值就在start到mid之间查询</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left_max <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果只在左子树</span>            left_max <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//求右边最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//横跨左右子树的情况，起点为mid+1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right_max <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果只在右子树</span>            right_max <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left_max<span class="token punctuation">,</span> right_max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三、线段树性质"><a href="#三、线段树性质" class="headerlink" title="三、线段树性质"></a>三、线段树性质</h2><p>对于区间[m1,m2]，mid = (m1+m2)/2，其左儿子区间是[m1,mid]，右儿子区间是(mid+1,m2)</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXBrZWYwc2tvajMxbWUwbXEweWguanBn?x-oss-process=image/format,png" alt="demo"></p><h2 id="四、题目练习"><a href="#四、题目练习" class="headerlink" title="四、题目练习"></a>四、题目练习</h2><h3 id="1、LintCode-206-Interval-Sum"><a href="#1、LintCode-206-Interval-Sum" class="headerlink" title="1、LintCode 206. Interval Sum"></a>1、LintCode 206. Interval Sum</h3><p>区间求和</p><blockquote><p>给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 <code>[start, end]</code> 。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的总和</p><pre><code>输入: 数组 ：[1,2,7,8,5], 查询：[(0,4),(1,2),(2,4)]输出: [23,9,20]</code></pre></blockquote><p>思路</p><ul><li>暴力，枚举O(nm)，n为数组长度，m为查询次数</li><li>线段树/树状数组，O(mlogn)</li><li>前缀和数组O(n+m)，这个题没有涉及到修改，可以用</li></ul><p>首先定义Node和树</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//线段树Node</span>    <span class="token keyword">class</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> start<span class="token punctuation">;</span>        <span class="token keyword">int</span> end<span class="token punctuation">;</span>        <span class="token keyword">long</span> sum<span class="token punctuation">;</span>        SegmentTreeNode left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SegmentTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>            sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            left <span class="token operator">=</span> right <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span>  <span class="token class-name">SegmentTree</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//区间</span>        <span class="token keyword">private</span> SegmentTreeNode root<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SegmentTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            size <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            root <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> SegmentTreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            SegmentTreeNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//递归出口，叶子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                node<span class="token punctuation">.</span>sum <span class="token operator">=</span> A<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//不是出口，递归建立左子树和右子树</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//别忘记维护当前节点的sum</span>            node<span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//查询对外界接口</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">querySum</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">querySum</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//重载方法.在node节点下查询原数组start到end区间内的和</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">querySum</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//递归出口</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> node<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">+</span> node<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> leftSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//左边区间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果不是跨区间</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    leftSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    leftSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//可以合并为一行 !!!!</span>                <span class="token comment" spellcheck="true">// leftSum = querySum(node.left, start, Math.min(mid, end));</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//要考虑右半区间，也就是start-end与右半区间有交集</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">>=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果不是跨区间</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rightSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    rightSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 可以合并为一句</span>                <span class="token comment" spellcheck="true">// rightSum = querySum(node.right, Math.max(mid + 1, start), end);</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>实现方法</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>        <span class="token function">Interval</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Long<span class="token operator">></span> <span class="token function">intervalSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Long<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SegmentTree segmentTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Interval query <span class="token operator">:</span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> sum <span class="token operator">=</span> segmentTree<span class="token punctuation">.</span><span class="token function">querySum</span><span class="token punctuation">(</span>query<span class="token punctuation">.</span>start<span class="token punctuation">,</span> query<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、LintCode-207-Interval-Sum"><a href="#2、LintCode-207-Interval-Sum" class="headerlink" title="2、LintCode 207.  Interval Sum"></a>2、LintCode 207.  Interval Sum</h3><blockquote><p>在类的构造函数中给一个整数数组, 实现两个方法 <code>query(start, end)</code> 和 <code>modify(index, value)</code>:</p><ul><li>对于 query(<em>start</em>, <em>end</em>), 返回数组中下标 <em>start</em> 到 <em>end</em> 的 <strong>和</strong>。</li><li>对于 modify(<em>index</em>, <em>value</em>), 修改数组中下标为 <em>index</em> 上的数为 <em>value</em>.</li></ul></blockquote><p>比206多了modify，无法使用前缀和数组，暴力O(nm)，线段树/树状数组O(mlogn)，n为数组长度，m为操作次数。</p><p>线段树类中提供三个方法</p><ul><li>构造器传入int[] A</li><li>querySum(int start, int end)</li><li>modify(int index, int val)</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> SegmentTree segmentTree<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> null <span class="token operator">||</span> A<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            segmentTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> segmentTree<span class="token punctuation">.</span><span class="token function">querySum</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            segmentTree<span class="token punctuation">.</span><span class="token function">modify</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> sum<span class="token punctuation">;</span>        <span class="token keyword">public</span> SegmentTreeNode left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SegmentTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>            sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            left <span class="token operator">=</span> right <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> SegmentTreeNode root<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SegmentTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            size <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            root <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> SegmentTreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            SegmentTreeNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//递归出口</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                node<span class="token punctuation">.</span>sum <span class="token operator">=</span> A<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//不是出口则递归建所有子树</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//公开接口</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">querySum</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">querySum</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//公开接口</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">modify</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">querySum</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> node<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">+</span> node<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这边不是start和end 是node的区间</span>            <span class="token keyword">long</span> leftSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                leftSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">>=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                rightSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//递归出口：到达这个叶子节点，并修改它的值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> node<span class="token punctuation">.</span>end <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                node<span class="token punctuation">.</span>sum <span class="token operator">=</span> val<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//递归：分为在左子树和右子树两种情况,不用求mid</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>end <span class="token operator">>=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">modify</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">modify</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//最后改下根</span>            node<span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、LintCode-248-Count-of-Smaller-Number"><a href="#3、LintCode-248-Count-of-Smaller-Number" class="headerlink" title="3、LintCode 248. Count of Smaller Number"></a>3、LintCode 248. Count of Smaller Number</h3><p>统计比给定整数小的数的个数</p><blockquote><p>给定一个整数数组 （下标由 0 到 n-1，其中 n 表示数组的规模，数值范围由 0 到 10000），以及一个查询列表。对于每一个查询，将会给你一个整数，请你返回该数组中小于给定整数的元素的数量。</p><pre><code>输入: array =[1,2,7,8,5] queries =[1,8,5]输出:[0,4,2]</code></pre></blockquote><p>时间复杂度：</p><ul><li>暴力求O(nm)，n为数组长度，m为查询次数</li><li>线段树/树状数组O(mlogk)，m为查询次数，k为数组最大值</li><li>二分,先排序，nlogn，然后查询比某个数小，只要得到它的位置即可，O(nlogn+mlogn)</li><li>前缀和数组，线性，O(k+n+m)，本题较好的方式，但是扩展较为困难</li></ul><p>线段树思路：</p><ul><li>数组内元素范围在0～10000，用数组B[i]代表i这个值出现了多少次，那么查询比x小的元素只要计算B的前缀和B[0]+B[1]+…+B[x-1]，那就是查询B数组的某一个区间和，查询时间复杂度为logk（k为数组最大值）。这个题用前缀和也是非常的方便，但是遇到follow up就不行了。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">countOfSmallerNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> B <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>                B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//建立线段树，大小为10001</span>            SegmentTree tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">(</span><span class="token number">10001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10001</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tree<span class="token punctuation">.</span><span class="token function">modify</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//i位置修改为B[i]，表示这个数出现了多少次</span>            <span class="token punctuation">}</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//没有数比0小，都是正数</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span><span class="token function">querySum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>             <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> sum<span class="token punctuation">;</span>        <span class="token keyword">public</span>  <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>        <span class="token keyword">public</span>  SegmentTreeNode left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SegmentTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>            sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            left <span class="token operator">=</span> right <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>        <span class="token keyword">private</span> SegmentTreeNode root<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SegmentTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>            root <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化得到的是全0的树</span>        <span class="token keyword">private</span> SegmentTreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            SegmentTreeNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySum</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">querySum</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//在node节点的子树下，查询[start,end]区间内维护的和</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySum</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> node<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> leftSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">+</span> node<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                leftSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">>=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                rightSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">modify</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> node<span class="token punctuation">.</span>end <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//可以省略node.end == index</span>                node<span class="token punctuation">.</span>sum <span class="token operator">=</span> val<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>end <span class="token operator">>=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">modify</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">modify</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//维护当前节点sum</span>            node<span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-249-Count-of-Smaller-Number-before-itself"><a href="#4、LintCode-249-Count-of-Smaller-Number-before-itself" class="headerlink" title="4、LintCode 249. Count of Smaller Number before itself"></a>4、LintCode 249. Count of Smaller Number before itself</h3><p>统计前面比自己小的数的个数</p><blockquote><p>给定一个整数数组（下标由 0 到 n-1， n 表示数组的规模，取值范围由 0 到10000）。对于数组中的每个 <code>ai</code> 元素，请计算 <code>ai</code> 前的数中比它小的元素的数量。</p><pre><code>输入:[1,2,7,8,5]输出:[0,1,2,3,2]</code></pre></blockquote><p>时间复杂度：</p><ul><li>暴力，O(n^2^)</li><li>树状数组/线段树，O(nlogk)，n为数组长度，k为数组最大值</li></ul><p>思路：</p><ul><li>数组内范围为0～10000，假设数组B，B[i]表示数组A当前元素之前有多少个i（或者说B[i]表示A中有多少个i，只不过它是实时变化的）。查询比x小的数的个数相当于求B的x-1前缀和，B[0]+B[1]+…+B[x-1]</li></ul><blockquote><p>A=[1,2,7,8,5] </p><p>B=[0,0,0,0,0,0,0,0,0]    初始，这里B得开9，因为0～8一共9位</p><p>B=[0,1,0,0,0,0,0,0,0]     B[1]++，统计比A中第二个元素(2)小的个数，B[0]+B[1]</p><p>B=[0,1,1,0,0,0,0,0,0]     B[2]++，A中第三个元素为7，计算B[0]+…+B[6]</p><p>B=[0,1,1,0,0,0,0,1,1]     B[7]++，A中第四个元素为8，计算B[0]+…+B[7]</p><p>B=[0,1,1,0,0,1,0,1,1]     B[8]++，A中第五个元素为5，计算B[0]+…+B[4]</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">countOfSmallerNumberII</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SegmentTree tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">(</span><span class="token number">10001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> B <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span><span class="token function">querySum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//更新B</span>            B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            tree<span class="token punctuation">.</span><span class="token function">modify</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>    <span class="token keyword">public</span> SegmentTreeNode left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SegmentTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        left <span class="token operator">=</span> right <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> SegmentTreeNode root<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SegmentTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//初始化得到的是全0的树</span>    <span class="token keyword">private</span> SegmentTreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SegmentTreeNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SegmentTreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySum</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">querySum</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//在node节点的子树下，查询[start,end]区间内维护的和</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySum</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> leftSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">+</span> node<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            leftSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">>=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rightSum <span class="token operator">=</span> <span class="token function">querySum</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> leftSum <span class="token operator">+</span> rightSum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">modify</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span>SegmentTreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>start <span class="token operator">==</span> node<span class="token punctuation">.</span>end <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>end <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//可以省略node.end == index</span>            node<span class="token punctuation">.</span>sum <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>end <span class="token operator">>=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">modify</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">modify</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> index<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//维护当前节点sum</span>        node<span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/10/%E5%8C%BA%E9%97%B4%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/10/%E5%8C%BA%E9%97%B4%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划：区间型"><a href="#动态规划：区间型" class="headerlink" title="动态规划：区间型"></a>动态规划：区间型</h2><p><strong>背景：</strong>给定一个序列或字符串要进行一些操作，最后一步要将序列或字符串<strong>去头、去尾</strong>，区间[i,j]变为区间[i+1,j-1]，力扣上面的最长回文子串就是这样子操作。区间型dp一般用dp[i] [j]，i代表左端点，j代表右端点，若有其他维度可再添加，若两个端点之间存在联系，则可再压缩空间。</p><p><strong>区间型dp不开n+1，开n，区间型dp要按照长度去算。不能按照i，要按照j-i。</strong></p><h3 id="1、LintCode-667-Longest-Palindromic-Subsequence"><a href="#1、LintCode-667-Longest-Palindromic-Subsequence" class="headerlink" title="1、LintCode 667 Longest Palindromic Subsequence"></a>1、<a href="https://www.lintcode.com/problem/longest-palindromic-subsequence/description" target="_blank" rel="noopener"><strong>LintCode 667 Longest Palindromic Subsequence</strong></a></h3><p>【问题】给一字符串 s,，找出在 s 中的最长回文子序列的长度.。你可以假设 s 的最大长度为 1000。</p><p>【分析】注意区分子串和子序列，子串是连续的，子序列可以不连续，这个题是子序列，可以不连续。从最后一步出发，假设S是最长回文子序列，长度为<code>len</code>，分析这个子序列有两种情况</p><ul><li>子序列长度为1，只有一个字母</li><li>子序列长度大于1，必有<code>S[0] = S[len-1]</code></li></ul><p>S是在区间<code>[i,j]</code>中的最长回文子串，对于最长子序列S去头去尾后<code>S[1..len-2]</code>仍然是一个回文串，并且是在区间<code>[i+1,j-1]</code>中的最长回文子串（应该说是在在长度为j-i+1 - 2时的最长回文子串），并且可以得出<code>S[i,j] = S[i+1,j-1] + 2</code></p><p>【转移方程】头尾不想等，去头、去尾各一种情况；头尾相等，同时去头去尾</p><ul><li><code>dp[i][j] = max{dp[i+1][j],dp[i][j-1],dp[i+1][j-1]+2 &amp;&amp; chs[i] == chs[j]}</code></li></ul><p>【初始条件】</p><ul><li><code>dp[0][0] = dp[1][1] = ...=dp[n-1][n-1] = 1</code>，每个字母都是长度为1的回文串</li><li>不能按照i去算，要按照长度len去算</li></ul><p>【答案】<code>dp[0][n-1]</code> 两个端点,画出图来就是右上三角</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//region length : 2 &lt;= len &lt;= n</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//startIndex i &lt;= n - len</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>要求打印路径</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//要求打印出路径</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">LPS</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//路径数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//去头记为0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//去尾记为1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//相等记为2</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//最长的长度为dp[0][n - 1]</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开始与结束两个指针</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//chs数组的两个指针</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从两头分别往中间去走</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果字符串长度为1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果字符串长度为2</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//其他情况,如果来自去头的情况</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果来自去尾的情况</span>                    <span class="token operator">--</span>j<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    res<span class="token punctuation">[</span>q<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>使用记忆化搜索优化，记忆化搜索使用递归，自上而下，递推是自下而上。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果算过了就直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//first recursion</span>        <span class="token function">compute</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compute</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compute</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//then dp</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindromeSubseq</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化所有格子标记为没有被访问过</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//通过递归的方式来填充f数组</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、LintCode-200-Longest-Palindromic-Substring"><a href="#2、LintCode-200-Longest-Palindromic-Substring" class="headerlink" title="2、LintCode 200 Longest Palindromic Substring"></a>2、<a href="https://www.lintcode.com/problem/longest-palindromic-substring/description" target="_blank" rel="noopener">LintCode 200 Longest Palindromic Substring</a></h3><p>【问题】给出一个字符串（假设长度最长为1000），求出它的最长回文子串，你可以假定只有一个满足条件的最长回文串。</p><p>【分析】一种方法是中心扩展法，另一种以区间型dp来做，假设最长回文字串是<code>s(i,j)</code>,那么它的去头去尾的子串<code>s&#39;(i+1..j-1)</code>也是在这个区间内的最长回文子串。假设最长回文子串的长度为<code>len</code>，len的范围是<code>0 &lt;= len &lt;= n</code>，枚举len，只需要记录最长的长度以及起点，就能得到子串。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">longestPalindrome2</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> longest <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//要单独处理下相邻的</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                longest <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                start <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//长度从3开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">></span> longest<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    longest <span class="token operator">=</span> len<span class="token punctuation">;</span>                    start <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> longest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、LintCode-396-Coins-In-A-Line-III——博弈-区间"><a href="#3、LintCode-396-Coins-In-A-Line-III——博弈-区间" class="headerlink" title="3、LintCode 396 Coins In A Line III——博弈+区间"></a>3、<a href="https://www.lintcode.com/problem/coins-in-a-line-iii/" target="_blank" rel="noopener">LintCode 396 Coins In A Line III</a>——博弈+区间</h3><p>【问题】给定一个序列a[0], a[1], …, a[N-1]，两个玩家Alice和Bob轮流取数，每个人每次只能取第一个数或最后一个数，双方都用最优策略，使得自己的数字和尽量比对手大，问先手是否必胜。（如果数字和一样，也算是先手胜）</p><p>【分析】不需要存己方数字和与对方数字和，只需记录差。两个人都记录着自己与对方的数字之差：S<del>A</del> = A - B，S<del>B</del> = B - A。A取走一个数字m后，B就变为先手，他想要最大化S<del>B</del> = B-A，对于A来说，此时S<del>A</del> = -S<del>B</del>+m，m就是当前这步的数字，m可能是头也可能是尾，选择能最大化S<del>A</del>的即可。取走之后对手也同样采取最优策略去拿。</p><p>【转移方程】</p><ul><li><p>状态：A先手取头，a[0],B此时最大数字差为S<del>B</del>，此时最大数字差为-S<del>B</del>+a[0]</p></li><li><p>状态：A先手取尾，a[n-1],B此时最大数字差为S<del>B</del>，此时最大数字差为-S<del>B</del>+a[n-1]</p></li><li><p>方程：<code>dp[i][j] = max{a[i] - dp[i+1][j],a[j] - dp[i][j-1]}</code></p></li></ul><p>【答案】<code>dp[0][n-1] &gt;= 0</code>则先生胜  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">firstWillWin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//枚举长度</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-430-Scramble-String"><a href="#4、LintCode-430-Scramble-String" class="headerlink" title="4、LintCode 430 Scramble String"></a>4、<a href="https://www.lintcode.com/problem/scramble-string/description" target="_blank" rel="noopener">LintCode 430 Scramble String</a></h3><p>【问题】攀爬字符串。给定一个字符串S，按照树结构每次二分成左右两个部分，直至单个字符，在树上某些节点交换左右儿子，可以形成新的字符串，判断一个字符串T是否由S经过这样的变换而成。</p><p>下面是 <code>s1 = &quot;great&quot;</code> 可能得到的一棵二叉树:</p><pre class=" language-txt"><code class="language-txt">      great     /    \    gr    eat   / \    /  \  g   r  e   at             / \            a   t</code></pre><p>在攀爬字符串的过程中, 我们可以选择其中任意一个非叶节点, 交换该节点的两个子节点.</p><p>例如，我们选择了 <code>&quot;gr&quot;</code> 节点,，并将该节点的两个子节点进行交换，并且将祖先节点对应的子串部分也交换,，最终得到了 <code>&quot;rgeat&quot;</code>。 我们认为 <code>&quot;rgeat&quot;</code> 是 <code>&quot;great&quot;</code> 的一个攀爬字符串。</p><pre class=" language-txt"><code class="language-txt">      rgeat     /    \    rg    eat   / \    /  \  r   g  e   at             / \            a   t</code></pre><p>类似地, 如果我们继续将其节点 <code>&quot;eat&quot;</code> 和 <code>&quot;at&quot;</code> 的子节点交换， 又可以得到 <code>&quot;great&quot;</code> 的一个攀爬字符串 <code>&quot;rgtae&quot;</code>。</p><pre class=" language-txt"><code class="language-txt">     rgtae     /    \    rg    tae   / \    /  \  r   g  ta   e         / \        t   a</code></pre><p>给定两个相同长度的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否为 <code>s1</code> 的攀爬字符串。</p><p>【分析】给定两个字符串T和S，假设T是由S变换而来</p><ul><li>如果T和S长度不一样，必定不能变来</li><li>如果长度一样，顶层字符串S能够划分为S1和S2，同样字符串T也能够划分为T1和T2<ul><li>情况一：没交换，<code>S1 ==&gt; T1，S2 ==&gt; T2</code></li><li>情况二：交换了，<code>S1 ==&gt; T2，S2 ==&gt; T1</code></li></ul></li><li>子问题就是分别讨论两种情况，T1是否由S1变来，T2是否由S2变来，或 T1是否由S2变来，T2是否由S1变来。</li></ul><p><img src="https://img-blog.csdnimg.cn/20191209094025664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qETkstTE-1575855579132)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191208150015394.png)\]"></p><p>【状态】<code>dp[i][j][k][h]</code>表示T[k..h]是否由S[i..j]变来。由于变换必须长度是一样的，因此这边有个关系<code>j - i = h - k</code>，可以把四维数组降成三维。<code>dp[i][j][len]</code> 表示从字符串S中i开始长度为len的字符串是否能变换为从字符串T中j开始长度为len的字符串</p><blockquote><p>dp[i] [j] [k] = OR<del>1&lt;=w&lt;=k-1</del>{dp[i] [j] [w] AND dp[i+w] [j+w] [k-w]}  或 OR<del>1&lt;=w&lt;=k-1</del>{dp[i] [j+k-w] [w] AND dp[i+w] [j] [k-w]}</p><p>枚举S1长度w（1～k-1，因为要划分），f[i] [j] [w]表示S1能变成T1，f[i+w] [j+w] [k-w]表示S2能变成T2，或者是S1能变成T2，S2能变成T1。</p></blockquote><p>【初始条件】对于长度是1的子串，只有相等才能变过去，相等为true，不相等为false。</p><p>【答案】<code>dp[0][0][n]</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isScramble</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs1 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs2 <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化单个字符的情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> chs1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//枚举长度2～n</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//枚举S中的起点位置</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//枚举T中的起点位置</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//枚举划分位置</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//第一种情况：S1->T1,S2->T2</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">[</span>len <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//第二种情况：S1->T2,S2->T1</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> len <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>`</code></pre><h3 id="5、LintCode-168-Burst-Balloons"><a href="#5、LintCode-168-Burst-Balloons" class="headerlink" title="5、LintCode 168 Burst Balloons"></a>5、<a href="https://www.lintcode.com/problem/burst-balloons/description" target="_blank" rel="noopener">LintCode 168 Burst Balloons</a></h3><p>【问题】有n个气球，编号为<code>0</code>到<code>n-1</code>，每个气球都有一个分数，存在<code>nums</code>数组中。每次吹气球i可以得到的分数为 <code>nums[left] * nums[i] * nums[right]</code>，left和right分别表示<code>i</code>气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。（最后一个气球被扎破即它本身，算作<code>1 * nums[i] * 1</code>）</p><p>【分析】区间型dp，从最后一步出发，最后一步必定扎破一个气球，编号为i，这一步获得金币<code>1*  nums[i] * 1</code>，此时i前面的气球<code>1～i-1</code>以及i后面的气球<code>i+1～n</code>都被扎破了，需要知道两边最多能获得多少个金币，再加上最后一步，就是结果。</p><p>【状态转移方程】由于最后一步是<code>1 * nums[i] * 1</code>，我们可以认为两端有两个不能扎破的气球，值为1，dp[i] [j]代表扎破i+1号气球～j-1号气球能获得的金币数，i和j是不能被扎破的，因为是两端，并且当前气球k不能被扎破，要分别考虑k的左侧（i～k-1）和右侧（k+1～j），状态转移方程为：</p><ul><li><code>dp[i][j] = max{dp[i][k] + dp[k][j] + a[i] * a[k] * a[j]},k∈(i,j)</code></li><li>dp[i] [k]代表扎破i+1～k-1号气球，dp[k] [j]代表扎破k+1～j-1号气球，再加上扎破这个气球获得的金币数</li></ul><p>【初始条件】没有气球要扎破就获得0个金币</p><ul><li><code>dp[0][1] = dp[1][2] = ... = dp[n-2][n-1] = 0</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//左右两个不能扎破的</span>        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            A<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化没有气球要扎破的情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从长度为3开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//开头</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//结尾</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//枚举中间的气球 作为不扎破的气球</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/04/%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/04/%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>序列型dp就是序列+状态，直接看几个例子。</p><h3 id="1、LintCode-515-Paint-House"><a href="#1、LintCode-515-Paint-House" class="headerlink" title="1、LintCode 515 Paint House"></a>1、<a href="https://www.lintcode.com/problem/paint-house/description" target="_blank" rel="noopener"><strong>LintCode 515 Paint House</strong></a></h3><p>【问题】这里有<code>n</code>个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得<strong>相邻的房屋颜色不同</strong>，并且费用最小，返回最小的费用。费用通过一个<code>nx3</code> 的矩阵给出，比如<code>cost[0][0]</code>表示房屋<code>0</code>染红色的费用，<code>cost[1][2]</code>表示房屋<code>1</code>染绿色的费用。</p><p>【分析】典型的序列型动态规划，序列型动态规划 = 序列+状态。确定状态，一共三种</p><ul><li>如果最优策略中，最后一栋是红色，那么倒数第二栋只能是蓝色或绿色</li><li>如果最优策略中，最后一栋是蓝色，那么倒数第二栋只能是红色或绿色</li><li>如果最优策略中，最后一栋是绿色，那么倒数第二栋只能是蓝色或红色</li></ul><p>那么需要分别记录倒数第二栋房子是红色、蓝色、绿色的最小花费即可，只要最后一栋和倒数第二栋颜色不一样。</p><p>初始条件：序列型dp需要开<code>n+1</code>行，每列表示一种状态，<code>dp[0][0] = dp[0][1] = dp[0][2] = 0</code>，第0栋房子花费是0。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCost</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>costs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> costs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//序列型动态规划，一共三种颜色，一共要rows栋房子，另外加一个第0栋存放初始值</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>rows <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第0栋</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//i是第i栋房子</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//第i栋房子要染成3种颜色种的哪一种</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//前i-1栋房子的颜色</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>rows<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>rows<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>rows<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、LintCode-516-Paint-House-II"><a href="#2、LintCode-516-Paint-House-II" class="headerlink" title="2、LintCode 516 Paint House II"></a>2、<a href="http://www.lintcode.com/problem/paint-house-ii/" target="_blank" rel="noopener">LintCode 516 Paint House II</a></h3><p>【问题】这里有<code>n</code>个房子在一列直线上，现在我们需要给房屋染色，共有<code>k</code>种颜色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小。费用通过一个<code>nxk</code> 的矩阵给出，比如<code>cost[0][0]</code>表示房屋<code>0</code>染颜色<code>0</code>的费用，<code>cost[1][2]</code>表示房屋<code>1</code>染颜色<code>2</code>的费用。</p><p>【分析】原来是三种颜色，现在变成k种颜色</p><p>第一种写法，直接把刚才的3改成现在的k，时间复杂度O(NK^2^)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">minCostII</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>costs <span class="token operator">==</span> null <span class="token operator">||</span> costs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> costs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//序列型</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//第0栋耗费为0</span>        <span class="token comment" spellcheck="true">//从第一栋房子开始</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//第一栋房子的三种颜色</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//前一栋房子</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> costs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>优化：上面的思路每次需要求<code>f[i-1][1], ..., f[i-1][K]</code>中除了一个元素之外，其他元素的最小值。这里解决思路是保存最小值和次小值，首先把<code>f[i-1][1], ..., f[i-1][K]</code>中的最小值和次小值先记录下来。</p><ul><li>如果除掉的元素不是最小值，那剩下的最小值就是最小值它本身</li><li>如果除掉的元素是最小值，那剩下的元素中，最小值就是次小值</li></ul><p>假设i-1栋房子，最小值是<code>f[i-1][a]</code>，次小值是<code>f[i-1][b]</code>，如果第i栋染颜色a，那么最小花费就是加上次小值，否则就是加上最小值。</p><p>时间复杂度O(NK)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">minCostII</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> costs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>costs <span class="token operator">==</span> null <span class="token operator">||</span> costs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> costs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//房屋数</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//颜色个数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//初始化第一行，第0栋</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> min1<span class="token punctuation">,</span> min2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//min1存放最小值，min2存放次小值</span>        <span class="token keyword">int</span> id1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//id1存放最小值的颜色下标，id2存放次小值的颜色下标</span>        <span class="token keyword">int</span> id2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            min1 <span class="token operator">=</span> min2 <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//第i-1栋房子的最小花费和次小花费</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果当前值比最小值还小，就把最小值先传递给次小值，再更新最小值,其次还要更新id</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min2 <span class="token operator">=</span> min1<span class="token punctuation">;</span>                    id2 <span class="token operator">=</span> id1<span class="token punctuation">;</span>                    min1 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    id1 <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//如果当前值比次小值小，但比最小值大，只需要更新次小值</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        min2 <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                        id2 <span class="token operator">=</span> j<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果和i-1栋颜色不一样,那就直接加最小值，否则加次小值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> id1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> min1 <span class="token operator">+</span> costs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> min2 <span class="token operator">+</span> costs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">></span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、LintCode-392-House-Robber"><a href="#3、LintCode-392-House-Robber" class="headerlink" title="3、LintCode 392 House Robber"></a>3、<a href="http://www.lintcode.com/problem/house-robber/" target="_blank" rel="noopener">LintCode 392 House Robber</a></h3><p>【问题】假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，<strong>在不触动报警装置的情况下</strong>, 你最多可以得到多少钱 。</p><p>简而言之，不能偷相邻两家，求最多能偷多少金币。</p><p>【分析】从最后一步出发，最后一栋房子i是偷还是不偷</p><ul><li>偷i，结果 = 第i栋的金币数 + 前i-2（包括i-2）栋偷得的总额</li><li>不偷i，结果 = 前 i-1（包括i-1） 栋房子的最优策略</li></ul><p><strong>两个状态，用0表示不偷，用1表示偷</strong></p><ul><li>第i栋不偷，i-1可偷可不偷，<code>dp[i][0] = max{dp[i-1][0], dp[i-1][1]}</code></li><li>第i栋选择偷，i-1不能偷，<code>dp[i][1] = dp[i-1][0] + A[i-1]</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//一般写法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">houseRobber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第0栋房屋</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//不偷</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//偷</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>简化：偷i栋房子时，i-1肯定不能偷，直接去问前i-2栋一功能偷多少，不偷i栋时，问前i-1栋能偷多少</p><ul><li><code>dp[i] = max{dp[i-1], dp[i-2] + A[i-1]}</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">houseRobber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//前0栋房子，0</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>使用滚动数组优化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">houseRobber2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//dp[0]</span>        <span class="token keyword">long</span> now <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//dp[1]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> t <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>old <span class="token operator">+</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            now <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> now<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-534-House-Robber-II"><a href="#4、LintCode-534-House-Robber-II" class="headerlink" title="4、LintCode 534 House Robber II"></a>4、<a href="http://www.lintcode.com/problem/house-robber-ii/" target="_blank" rel="noopener">LintCode 534 House Robber II</a></h3><p>【问题】上一题是一排房子，现在是一圈房子，然后不能偷任何挨着的两家，求最多能偷多少金币。</p><p>【分析】现在第一栋房子和最后一栋房子成了邻居，首尾不能同时偷，就有两种情况：①偷第一栋，最后一栋不能偷，②偷最后一栋，第一栋不能偷。所以只要分别计算去头和去尾两种情况，取一个最大值即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">houseRobber2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//去尾的情况</span>        <span class="token punctuation">}</span>        res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">calc</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//去头的情况</span>        <span class="token punctuation">}</span>        res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">calc</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//dp[0]</span>        <span class="token keyword">long</span> now <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//dp[1]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//now = dp[i-1],old = dp[i-2]</span>            <span class="token keyword">long</span> t <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>old <span class="token operator">+</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            now <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> now<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5、LintCode-149-买卖股票的最佳时机I"><a href="#5、LintCode-149-买卖股票的最佳时机I" class="headerlink" title="5、LintCode 149 买卖股票的最佳时机I"></a>5、<a href="http://www.lintcode.com/en/problem/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LintCode 149 买卖股票的最佳时机I</a></h3><p>【问题】假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交易(例如,一次买卖股票),设计一个算法来找出最大利润。</p><p>【分析】维护到当前位置i的最小值，<code>利润 = 当天卖出价格 - 最小值价格</code>，更新res数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> minVal <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            minVal <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="6、LintCode-149-买卖股票的最佳时机II"><a href="#6、LintCode-149-买卖股票的最佳时机II" class="headerlink" title="6、LintCode 149 买卖股票的最佳时机II"></a>6、<a href="http://www.lintcode.com/en/problem/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">LintCode 149 买卖股票的最佳时机II</a></h3><p>【问题】给定一个数组 <code>prices</code> 表示一支股票每天的价格.你可以完成任意次数的交易, 不过你不能同时参与多个交易 (也就是说, 如果你已经持有这支股票, 在再次购买之前, 你必须先卖掉它).设计一个算法求出最大的利润。</p><p>简而言之：I中只能买卖一次，<strong>现在可以买卖任意多次</strong>，任何时刻最多持有一股，求获得的最大利润。</p><p>【分析】贪心，只要今天价格比昨天价格高，就卖掉，这里贪心就是最优的，因为抓住了每一个上升段<br><img src="https://img-blog.csdnimg.cn/20191208000849515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//只要比昨天价格高，就卖掉</span>                res <span class="token operator">+=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="7、LintCode-151-买卖股票的最佳时机III——序列型"><a href="#7、LintCode-151-买卖股票的最佳时机III——序列型" class="headerlink" title="7、LintCode 151 买卖股票的最佳时机III——序列型"></a>7、<a href="http://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">LintCode 151 买卖股票的最佳时机III</a>——序列型</h3><p>【问题】假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。<strong>你最多可以完成两笔交易</strong>。你不可以同时参与多笔交易(你必须在再次购买前出售掉之前的股票)</p><p><strong>限定交易次数为2次，不能手里同时有两支股票，可以同一天卖完后买入</strong></p><p>【分析】需要记录已经买卖多少次。最后一步就是最后一次卖掉，发生在第j天，需要枚举最后一次买是在第几天，但不知道之前有没有买卖过，所以<strong>需要记录状态</strong>，一共五种状态如下所示<br><img src="https://img-blog.csdnimg.cn/20191208000901298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>阶段1、3、5手里虽然没股票，但是境界不一样，分别是买卖过0次、1次、2次</li><li>阶段2、4是持有股票阶段，可以选择持有股票或卖出</li><li>最优策略必定处于阶段1、3、5，不可能处于2、4，买了不卖，那就亏了。所以需要求在阶段1、阶段3、阶段5时三种清仓状态下的最大获利分别是多少。</li></ul><p>【状态转移方程】</p><ul><li><code>dp[i][j]</code>表示前i天（第i-1）天结束后，在阶段j的最大获利</li><li>阶段1、3、5，无股票状态，两种可能：昨天无股票并保持无股票状态 或 昨天有股票今天卖出<ul><li><code>dp[i][j] = max{dp[i-1][j],dp[i-1][j-1] + prices[i-1] - prices[i-2]}</code></li></ul></li><li>阶段2、4，手里持有股票，两种可能：昨天有股票并保持有股票状态（获利和亏损都有可能，要加上） 或 昨天没股票今天买入<ul><li><code>dp[i][j] = max{dp[i-1][j] + prices[i-1] - prices[i-2],dp[i-1][j-1]}</code></li></ul></li></ul><p>【初始化与边界】</p><ul><li><code>dp[0][1] = 0;dp[0][2] = ... = dp[0][5] = Integer.MIN_VAULE</code></li><li>注意几个边界</li><li>最多买卖两次，必定在清仓状态下获利最多</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//遍历n天的价格</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//阶段1、3、5，手里不持有股票</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//肯定是第一个阶段以后的，所以j>1,且上一个阶段dp[i - 1][j - 1]不能为无穷小</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//继续不持有，或者昨天持有，今天卖掉变为不持有</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//阶段2、4，手里持有股票</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//从上一个不持有的阶段变为持有</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//不用判断j，从阶段2开始，且昨天持有时dp[i - 1][j]不能为无穷小</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//继续持有，继续获利，或是今天才买入</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="8、LintCode-393-买卖股票的最佳时机IV"><a href="#8、LintCode-393-买卖股票的最佳时机IV" class="headerlink" title="8、LintCode 393 买卖股票的最佳时机IV"></a>8、<a href="https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-iv/description" target="_blank" rel="noopener">LintCode 393 买卖股票的最佳时机IV</a></h3><p>【问题】在买卖股票的最佳时机III的中，买卖次数为2次，在这里变为K次买卖。</p><p>【分析】原来2次买卖股票，分为5个阶段，现在K次买卖，就分成了2K+1次</p><ul><li>阶段<code>1、3、5...2K+1</code>都是没有持有股票的阶段</li><li>阶段<code>2、4、6...2K</code>都是持有股票的阶段</li></ul><p>这样就能直接套买卖股票III中的模版了，但是解题时发现超时，因为当<code>K &gt; N/2</code>时，直接退化为任意次买卖股票了，需要特殊考虑，解题代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>K <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res <span class="token operator">+=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> K <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//初始化</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//阶段1、3、5...2K+1，不持有股票</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//初始是继续保持不持有的状态</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//保持不持有的状态或是昨天有股票，今天卖出</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//阶段2、4、6...2K，持有股票的阶段</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> K<span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//初始是从不持有的阶段过来</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//继续保持持有阶段并获利，或是昨天没有，今天买入</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="9、LintCode-76-最长上升子序列"><a href="#9、LintCode-76-最长上升子序列" class="headerlink" title="9、LintCode 76 最长上升子序列"></a>9、<a href="http://www.lintcode.com/problem/longest-increasing-subsequence/" target="_blank" rel="noopener">LintCode 76 最长上升子序列</a></h3><p>【问题】给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。<strong>这里可以不连续，因为是子序列，不是子串。</strong></p><p>【分析】假设最长上升子序列是以a[j]结尾的，那么子序列中倒数第二个元素必定比a[j]小</p><ul><li>很容易得出<code>f[j] = max{1, f[i] + 1 | i &lt; j &amp;&amp; a[i] &lt; a[j]}</code>，答案是其中的最大值</li></ul><p>写出如下代码，这里我试着打印子序列的路径，时间复杂度为O(N^2^)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">longestIncreasingSubsequence</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//记录路径</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//初始路径为-1</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果第i个个来自j处，那就更新</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//记下来是在哪结束的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>res<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>            end <span class="token operator">=</span> path<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> temp<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>优化：时间复杂度为O(nlogn)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 优化成O(N logN),看到这个就只有二分法了     * 优化:一旦前面有两个dp值一样了，比如dp[i] = dp[j],并缺nums[i] > nums[j] ，那就只要考虑第j个就可以了     * 也就是 同样的dp值，存一个坐标，这个坐标对应的nums[index]值最小。那么对于每个dp值，保存一下对应的nums[i]的值     * 序列是单调上升的，在单调上升中找最后一个比自己小的数用二分法     * 我们开个数组，数组的下表为dp值，对应存的是该dp值下最小的nums[idx]     */</span>    <span class="token comment" spellcheck="true">//1、使用 binarySearch()</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">longestIncreasingSubsequence</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//在a数组的这个区间内找有没有nums[i]，如果key在数组中，则返回搜索值的索引；否则返回-1或“-”（插入点）。插入点是索引键将要插入数组的那一点</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果如果这个数比之前的数大，就找不到插入位置，它就会在新位置插入，如果这个数比之前的数小，就会直接覆盖之前的数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index <span class="token operator">=</span> <span class="token operator">-</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//把这个数放在插入点上</span>            a<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用TreeSet     * TreeSet基本操作全是log(n)复杂度（欢迎纠正），时间复杂度也一致。     * TreeSet.ceiling(x)方法可以直接找出set中大于x的最小数字，如果不存在则返回null。     *     * 1. 如果这个数字存在，则删除这个数字，然后把x插入set中，相当于代替该数字。     * 2. 如果这个数字不存在，说明x大于set中任何数字，直接把x插入set中。     * 最后返回set的大小即可。     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestIncreasingSubsequence</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer ceiling <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">ceiling</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果set中大于num的最小数字存在，删除这个数字，放入num</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ceiling <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ceiling<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="10、LintCode-602-俄罗斯套娃信封"><a href="#10、LintCode-602-俄罗斯套娃信封" class="headerlink" title="10、LintCode 602 俄罗斯套娃信封"></a>10、<a href="https://www.lintcode.com/problem/russian-doll-envelopes/description" target="_blank" rel="noopener">LintCode 602 俄罗斯套娃信封</a></h3><p>【问题】给一定数量的信封，带有整数对 <code>(w, h)</code> 分别代表信封宽度和高度。一个信封的宽高均大于另一个信封时可以放下另一个信封。求最多嵌套多少个信封。</p><p>【分析】这个属于最长序列型dp，dp都是从最后一步出发，先考虑最后一步，也就是最后一个信封E<del>i</del>，然后考虑次外层信封，一定是某个E<del>j</del>，并且E<del>j</del>里面嵌套的信封也是最多的。得出</p><ul><li><code>dp[i] = max{1,dp[j] + 1}</code>（①只能这一个信封，②E<del>j</del>能放进E<del>i</del>中）dp[i]表示以信封E<del>i</del>为最外层信封时，最多嵌套层数。</li></ul><p>由于有宽和高两个维度，我们选择一个维度，比如选择宽度，先按照以宽度升序排序</p><p><strong>下面算法是正常思路，但时间复杂度为O(N^2^)，在Lintcode上通过不了，必须要O(nlogn)，但在Leetcode上能通过。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>envelopes <span class="token operator">==</span> null <span class="token operator">||</span> envelopes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//首先对信封按长度进行升序排序，如果长度一样则按照宽度进行升序排序</span><span class="token comment" spellcheck="true">/*        Arrays.sort(envelopes, new Comparator&lt;int[]>() {            @Override            public int compare(int[] o1, int[] o2) {                int res = o1[0] - o2[0];                    if (res == 0) {                    return o1[1] - o2[1];                } else {                    return res;                }            }        });*/</span>          <span class="token comment" spellcheck="true">//直接用lamda表达式</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> envelopes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//初始化,别忘记</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//i前面所有的信封</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> envelopes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> envelopes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>使用二分优化，原理和最长上升序列一样</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用二分</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxEnvelopes2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>envelopes <span class="token operator">==</span> null <span class="token operator">||</span> envelopes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> envelopes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> envelopes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 先按 w 升序排序，再按 h 降序 排序！！</span>        <span class="token comment" spellcheck="true">// 然后只需考虑h即可，因为w已经升序排列好，因为h大的在前，所以相同的w下的不同h，只会选择最大的那个h，来看以这个h结尾的最长上升子序列</span>        <span class="token comment" spellcheck="true">// 当w相同的情况下，h高的在前面，也就是说同样w中是不可能满足increasing subsequence的序列存在，所以任何的increasing subsequence的w一定都是升序的</span>        <span class="token comment" spellcheck="true">// 就可以将问题转换为 h 的 Longest Increasing subSequence</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>envelopes<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">:</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index <span class="token operator">=</span> <span class="token operator">-</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                len<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/02/%E8%83%8C%E5%8C%85%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/02/%E8%83%8C%E5%8C%85%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划：背包型"><a href="#动态规划：背包型" class="headerlink" title="动态规划：背包型"></a>动态规划：背包型</h2><p>数组开n+1，背包关键就是看最后一步。</p><h3 id="1、LintCode-92-Backpack"><a href="#1、LintCode-92-Backpack" class="headerlink" title="1、LintCode 92: Backpack"></a>1、<a href="https://www.lintcode.com/problem/backpack/description" target="_blank" rel="noopener"><strong>LintCode 92: Backpack</strong></a></h3><p>【问题】在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p><p>【分析】从最后一步出发，最后一个物品放还是不放。有两种情况</p><ul><li>前n-1个物品能拼出重量 <code>w</code>，那么n个物品也能拼出重量<code>w</code></li><li>前n-1个物品能拼出重量 <code>w - A[n-1]</code>，再加上最后一个物品 <code>A[n-1]</code> 拼出<code>w</code></li></ul><p>【状态转移】</p><ul><li><code>dp[i][w]</code>表示能否用前i个物品拼出重点w，可以用int数组，也可以用boolean数组，</li><li><code>dp[i][j] = max{dp[i-1][j], dp[i-1][j - A[n-1]] + A[i-1]}</code>（int数组）放还是不放</li><li><code>dp[i][j] = dp[i-1][w] or dp[i-1][j - A[i-1]]</code>（boolean数组）</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//int型写法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">backPack2</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//不放</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//放</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//boolean型写法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">backPack</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//物品个数</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//首先初始化dp[i][0]</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//不放</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//放</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// |=,只要有一个为true就是true</span>                    <span class="token comment" spellcheck="true">// 放入A[i-1]的情况就是看j-A[i-1]这个容量下是不是为true，如果为true，那么就是dp[i][j]为true，否则就是看dp[i-1][j]是否为true</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>优化成一维</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">backPack</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//不放和放，不放就是它自身，</span>                f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j <span class="token operator">-</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、LintCode-563-Backpack-V"><a href="#2、LintCode-563-Backpack-V" class="headerlink" title="2、LintCode 563: Backpack V"></a>2、<a href="http://www.lintcode.com/problem/backpack-v/" target="_blank" rel="noopener">LintCode 563: Backpack V</a></h3><p>【问题】给出 n 个物品, 以及一个数组, <code>nums[i]</code> 代表第i个物品的大小, 保证大小均为正数, 正整数 <code>target</code> 表示背包的大小, 找到能填满背包的方案数。<strong>注意：每一个物品只能使用一次。</strong></p><p>【分析】需要求出有多少种组合能组合成target，对于最后一个物品，有放和不放两种选择。</p><ul><li>第一种：使用前n-1个物品拼出target</li><li>第二种：前n-1个物品能拼出<code>target - nums[i]</code>，再加上nums[i]，拼出target</li><li>拼出target的方式 = 不放+放,即<code>dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i-1]]</code></li><li>如果知道有多少种方式拼出0、1、2…对于有多少种方式拼出target也就知道答案了。</li></ul><p>常规写法，时间复杂度O(n*Target)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">backPackV1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//dp[i][j]表示前i个数字有多少种方式拼出数字j</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//0个物品有一种方式拼出重量0</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//拼出几</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//不放</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//放</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                         dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>第一步优化：利用滚动数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">backPackV3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span><span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//不放</span>                dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//放</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>第二步优化：优化成一行。原本是 老值 + 老值 = 新值，如果正着更新，可能会出现 老值 + 新值，所以需要倒着更新</p><p><code>dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i-1]]</code>，新值 = 两个老值加起来</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">backPackV2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//和总称重有关</span>        <span class="token comment" spellcheck="true">//init：相当于dp[0][0] = 1</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//init：dp[0][1] = dp[0][2] = ... = 0</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//reverse</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> target<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//old + old ==> new old1 = dp[j],old2 = dp[j - nums[i - 1]],new就是直接覆盖</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、LintCode-564-Backpack-VI"><a href="#3、LintCode-564-Backpack-VI" class="headerlink" title="3、LintCode 564: Backpack VI"></a>3、<a href="https://www.lintcode.com/problem/combination-sum-iv/description" target="_blank" rel="noopener">LintCode 564: Backpack VI</a></h3><p>【问题】给出一个都是正整数的数组 <code>nums</code>，其中没有重复的数。从中找出所有的和为 <code>target</code> 的组合个数。<strong>注意一个数可以在组合中出现多次，数的顺序不同则会被认为是不同的组合。</strong></p><p>【分析】这个题和Backpack V的区别是每个物品可以使用多次，且组合中数字可以按照不同顺序，比如1+1+2与1+2+1算是两种情况，这就导致不能按照物品顺序来处理。依旧是关注最后一步，最后一步物品重量是K，那么前面物品构成重量target-K，需要关注最后一个加进来的是谁。</p><ul><li>如果最后一个物品重量是A<del>0</del>, 则要求有多少种组合能拼成 Target – A<del>0</del></li><li>如果最后一个物品重量是A<del>1</del>, 则要求有多少种组合能拼成 Target – A<del>1</del></li><li>……</li><li>如果最后一个物品重量是A<del>n-1</del>, 则要求有多少种组合能拼成 Target – A<del>n-1</del></li></ul><p>【状态转移方程】dp[i]代表有多少种组合能拼出重量i，则<code>dp[i] = dp[i-A[0]] + dp[i-A[1]] +...+ dp[i-A[n-1]]</code></p><p>【初始条件】<code>dp[0] = 1</code>，有1种组合能拼出0</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">backPackVI</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对于能拼出的i</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//初始化能拼出i的情况为0种</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//遍历所有数字</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-125-Backpack-II"><a href="#4、LintCode-125-Backpack-II" class="headerlink" title="4、LintCode 125: Backpack II"></a>4、<a href="http://www.lintcode.com/problem/backpack-ii/" target="_blank" rel="noopener">LintCode 125: Backpack II</a></h3><p>【问题】有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值。问最多能装入背包的总价值是多大？<strong>注意：每个物品只能取一次，物品不能切分。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">backPackII</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> V<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//不放</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//放</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> V<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5、LintCode-440-Backpack-III"><a href="#5、LintCode-440-Backpack-III" class="headerlink" title="5、LintCode 440: Backpack III"></a>5、<strong>LintCode 440: Backpack III</strong></h3><p>【问题】将Backpack II的物品改为无穷多个，背包最大承重m，求能带走的最大价值。</p><ul><li>输入:4个物品，重量为2, 3, 5, 7，价值为1, 5, 2, 4. 背包最大承重是10</li><li>输出:15</li></ul><p>【分析】A<del>i-1</del>有无穷多个，可以用1个、2个…在这里可以把物品变为种类，这边状态转移方程变为</p><ul><li>f[i] [w] = max<del>k&gt;=0</del>{f[i-1] [w-kA<del>i-1</del>] + kV<del>i-1</del>}，表示用<strong>前i种</strong>物品拼出重量w时的最大总价值，<strong>等于用前i-1种物品拼出重量w-kA<del>i-1</del> 时最大总价值，加上k个第i种物品</strong>，当k = 0和1时，就可以直接用在Backpack II 中了。</li></ul><p>把这个式子展开，如下</p><p><img src="https://img-blog.csdnimg.cn/20191208001351399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uCecL0xb-1575735182775)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191207222836105.png)\]"></p><p><strong>可以优化</strong></p><p><img src="https://img-blog.csdnimg.cn/20191208001359592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-shXqPs9c-1575735182776)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191207223019634.png)\]"></p><p><strong>什么意思呢</strong></p><blockquote><p>假设A<del>i-1</del> = 2,V<del>i-1</del> = x</p><p>f[i] [5] = max{ f[i-1] [5], f[i-1] [3] + x, f[i-1] [1] + 2x }</p><p>f[i] [7] = max{ f[i-1] [7], f[i-1] [5] + x, f[i-1] [3] + 2x, f[i-1] [1] + 3x }</p></blockquote><p>这样算了重合的部分，不是我们想要的</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 只需要把Backpack II中关键一行改为</span><span class="token comment" spellcheck="true">// dp[i][j] = Math.max(dp[i][j],dp[i][j - A[i-1]] + V[i-1])</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">backPackII</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> V<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//不放</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//放</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> V<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以优化到一维，这边的细节是：用的不是两个old值，而是old+new，可以只开一个数组，old+new去覆盖本来的old，这就需要时从前往后来，而不是逆序，如图</p><p><img src="https://img-blog.csdnimg.cn/20191208001438509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">backPackIII</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> V<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//old = dp[j],new = dp[j - A[i - 1] + V[i - 1]],加起来覆盖本来的old</span>                    <span class="token comment" spellcheck="true">//old相当于原来的dp[i-1][j],dp[j - A[i - 1]相当于dp[i][j - A[i - 1]</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> V<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/02/%E5%88%92%E5%88%86%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/02/%E5%88%92%E5%88%86%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划：划分型"><a href="#动态规划：划分型" class="headerlink" title="动态规划：划分型"></a>动态规划：划分型</h2><p><strong>划分型动态规划就是给定长度为N的字符串，需要划分成若干段，段数不限，每一段满足一定的性质。在学校oj中做过的书本分发、漆狗屋这种就属于划分型。开数组也是开<code>n+1</code></strong></p><h3 id="1、Lintcode-512-解码方法"><a href="#1、Lintcode-512-解码方法" class="headerlink" title="1、Lintcode 512 解码方法"></a>1、<a href="https://www.lintcode.com/problem/decode-ways/description" target="_blank" rel="noopener">Lintcode 512 解码方法</a></h3><p>【问题】有一个消息包含<code>A-Z</code>通过以下规则编码：’A’ -&gt; 1，’B’ -&gt; 2…’Z’ -&gt; 26，现在给你一个加密过后的消息，问有几种解码的方式。</p><pre><code>输入: &quot;12&quot;输出: 2解释: 它可以被解码为 AB (1 2) 或 L (12).</code></pre><p>【分析】从最后一步出发，最后一个或两个数字对应一个字母。给定字符串长度为N，需要球它的解密方式有多少种，那就需要知道前N-1个数字有多少种解密方式，以及前N-2个数字有多少种解密方式，这就是子问题。</p><p>【状态转移方程】<code>dp[i] = dp[i-1] + dp[i-2]</code> (最后两个字母范围为10~26) </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//空串也算一种</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//一位数必须要在1～9，0是不算的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">>=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">&lt;=</span> <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、Lintcode-513-Perfect-Squares"><a href="#2、Lintcode-513-Perfect-Squares" class="headerlink" title="2、Lintcode 513 Perfect Squares"></a>2、<a href="https://www.lintcode.com/problem/perfect-squares/description" target="_blank" rel="noopener">Lintcode 513 Perfect Squares</a></h3><p>【问题】给一个正整数 n, 请问最少多少个完全平方数(比如1, 4, 9…)的和等于n。</p><p>【分析】重点关注最后一个完全平方数 j^2^，n - j^2^ 也是被分成最少的完全平方数之和，这就是子问题</p><ul><li><code>dp[i]</code>就代表i最少被分成几个完全平方数之和，<code>dp[i] = min{dp[i - j^2]+1}</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//j必须从1开始，如果不从1开始，dp[i],dp[i]+1会越界</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">*</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、Lintcode-108-Palindrome-Partitioning-II"><a href="#3、Lintcode-108-Palindrome-Partitioning-II" class="headerlink" title="3、Lintcode 108 Palindrome Partitioning II"></a>3、<a href="http://www.lintcode.com/problem/palindrome-partitioning-ii/" target="_blank" rel="noopener">Lintcode 108 Palindrome Partitioning II</a></h3><p>【问题】给定字符串 <code>s</code>, 需要将它分割成一些子串， 使得每个子串都是回文串，最少需要分割几次?</p><p>【分析】从最后一步出发，假设最后一段回文串为s[j…n-1]，需要知道s中前j个字符[0…j-1]最少可以划分成多少个回文串，这就是子问题。</p><ul><li><code>dp[i] = min{dp[j]} + 1</code>(0 &lt;= j &lt; i &amp;&amp; s[j…i-1]为回文串的情况下)</li><li>初始条件：空串可以被划分为0个回文串</li></ul><p>下面这么写，超时</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCut</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果最后一段是回文串</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//问的是切几刀，刀数 = 段数 - 1，比如aab，分两段，切1刀</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>需要把所有的回文串保存在二维数组中，这样不用每次再去判断是否为回文串</p><p>时间复杂度O(N^2^)，空间复杂度O(N^2^)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCut</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> isPalindrome <span class="token operator">=</span> <span class="token function">calcPalindrome</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//判断是否为回文串</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//前0个回文串分割0个</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果j到i-1是回文串，就更新</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>isPalindrome<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//aab，分成两段回文串只要切一刀，段数 - 1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//利用二维数组，不用每次去判断是不是回文串</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calcPalindrome</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//从i到j是否为回文串，所以j是从i开始</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//生成回文串的过程，如果回文串长度是奇数，那就是由中心点向两边生成，如果回文串长度是偶数，那就是由中心线向两边生成</span>        <span class="token comment" spellcheck="true">//奇数的情况，c为中心center,共n个中心点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">,</span> j <span class="token operator">=</span> c<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i<span class="token operator">--</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//偶数的情况，共n-1条中心线</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">,</span> j <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> chs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i<span class="token operator">--</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-437-Copy-Books"><a href="#4、LintCode-437-Copy-Books" class="headerlink" title="4、LintCode 437 Copy Books"></a>4、<a href="https://www.lintcode.com/problem/copy-books/description" target="_blank" rel="noopener">LintCode 437 Copy Books</a></h3><p>书本分发、漆狗屋这类题，在学校OJ做烂掉了。这个题也能二分法做。</p><p>【问题】给定 n 本书, 第 i 本书的页数为 pages[i]。 现在有 k 个人来复印这些书籍,，而每个人只能复印编号连续的一段的书, 比如一个人可以复印 pages[0], pages[1], pages[2], 但是不可以只复印 pages[0], pages[2], pages[3]而不复印 pages[1]。所有人复印的速度是一样的,，复印一页需要花费一分钟, 并且所有人同时开始复印. 怎样分配这 k 个人的任务, 使得这 n 本书能够被尽快复印完?返回完成复印任务最少需要的分钟数。</p><p>【分析】当有i个抄写员的时候，一共n本书，从最后一步出发，第i个抄写员抄几本书，可能是0～n本，假设第i个抄写员抄写j本，前i-1个抄写员一共抄写n-j本书。前i-1个抄写员抄写完耗时T1，第i个抄写员抄写完耗时T2，i个人抄完n本书，花费的时间是max(T1,T2)，我们要求所有分配情况下，抄完书的最小时间花费。</p><p><img src="https://img-blog.csdnimg.cn/20191208001032100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xmlSXoMz-1575735008794)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191207200642303.png)\]"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//k个抄写员</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一共几本书</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化：k个抄写员抄写0本书，花费时间都是0</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化：0个抄写员抄写0本书，花费时间是0，0个抄写员抄写1本、2本。。。花费时间无穷大</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//一共前i个抄写员</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//前i个抄写员一共抄写j本书</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//前i-1个抄写员抄写l本书，l从j开始，也就是先让最后一个人从0本开始，然后累加，这样就不用额外去计算这个人抄写花费的时间</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> j<span class="token punctuation">;</span> l <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> l<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>二分法，二分可能的答案。每次判断什么呢？判断k个人能不能在这个时间（mid）里搞定</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//二分，时间复杂度O(nlogm), n:书本数目, m:总页数。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copyBooks</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pages<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 假设的做二分查找的区间是 0 ～ max</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//end为所有书都由一个人抄</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pages<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            end <span class="token operator">+=</span> pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//log page，N本书for检查一遍,O(n)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果k个人能在mid时间内搞定，说明我们可以继续 【缩短】 时间，而不是提高时间！！！</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>pages<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                end <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//double check start</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>pages<span class="token punctuation">,</span> start<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> start<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> end<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pages<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//所需人数</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//每个人工作了多久</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> page <span class="token operator">:</span> pages<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>page <span class="token operator">></span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//一定要判断一下！！！</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">+</span> page <span class="token operator">></span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                num<span class="token operator">++</span><span class="token punctuation">;</span>                count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count <span class="token operator">+=</span> page<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> num <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/02/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/02/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划：双序列型"><a href="#动态规划：双序列型" class="headerlink" title="动态规划：双序列型"></a>动态规划：双序列型</h2><p><strong>双序列型</strong>，就是有两个子序列/字符串，每个序列本身是一维的，可以转换为二维dp，序列型开数组开n+1，双序列型也是开n+1。</p><p><strong>突破口</strong>：看串A和串B的最后一个字符是否匹配，是否需要串A/串B的最后一个字符，来缩减规模。</p><p><strong>两种类型</strong>：计数型：情况1+情况2+…以及最值型min/max{情况1，情况2…}</p><p><strong>初始条件</strong>：要特别当心空串的处理。</p><h3 id="1、LintCode-77-Longest-Common-Subsequence"><a href="#1、LintCode-77-Longest-Common-Subsequence" class="headerlink" title="1、LintCode 77 Longest Common Subsequence"></a>1、<a href="http://www.lintcode.com/problem/longest-common-subsequence/" target="_blank" rel="noopener">LintCode 77 Longest Common Subsequence</a></h3><p>【问题】最长公共子序列。给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p><p>【分析】字符串A的长度为<code>m</code>，字符串B的长度为<code>n</code>，要组成最长公共子串一定是一个个对子，不能交叉，要按照顺序来，假设现在得到了最长公共子序列，有这么几种情况：</p><ul><li>字符串A的最后一个字符不在这个LCS中，那最长公共子串就是A中下标为<code>0～m-2</code>与B中下标为<code>0～n-1</code>的字符串的<code>最长公共子序列</code>。</li><li>字符串B的最后一个字符不在这个LCS中，那最长公共字串就是B中下标为<code>0～n-2</code>与A中下标为<code>0～m-1</code>的字符串的<code>最长公共子序列</code></li><li>字符串A中的最后一个字符与B中的一个字符正好是一对，那最长公共字串就是A中下标为<code>0～m-2</code>与B中下标为<code>0～n-2</code>的字符串的<code>最长公共子序列+A[m-1]</code></li></ul><p>【转移方程】dp[i] [j]代表A中前i个字符和B中前j个字符</p><ul><li><code>dp[i][j] = max{dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + 1|A[i-1]=B[j-1]}</code></li></ul><p>时间复杂度O(MN)，空间复杂度O(MN)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//双序列型的本质还是序列型</span>        <span class="token comment" spellcheck="true">//初始化第0行和第0列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                           dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以用滚动数组优化空间复杂度至O(N)</p><p>Plus：要求打印所有路径</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">LCS</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果A的最后一个不在其中，或者是B的最后一个不在其中的情况</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果最后一个都在其中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//+1 ！！！</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//获得了dp数组，dfs获取结果</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> dp<span class="token punctuation">,</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//打印结果</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>String temp<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> String A<span class="token punctuation">,</span> String B<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//只有相等时才添加</span>            temp <span class="token operator">+=</span> A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> dp<span class="token punctuation">,</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//上边更大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> dp<span class="token punctuation">,</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//左边更大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> dp<span class="token punctuation">,</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、LintCode-29-Interleaving-String"><a href="#2、LintCode-29-Interleaving-String" class="headerlink" title="2、LintCode 29 Interleaving String"></a>2、<a href="http://www.lintcode.com/en/problem/interleaving-string/" target="_blank" rel="noopener"><strong>LintCode 29 Interleaving String</strong></a></h3><p>【问题】交错字符串。给出三个字符串：s1、s2、s3，判断s3是否由s1和s2交叉构成。</p><blockquote><pre class=" language-text"><code class="language-text">输入：s1=“aabcc” s2=“dbbac”, s3=“aadbbcbcac” 输出：True( s3=“aadbbcbcac” )【分析】首先如果s3的长度不等于s1+s2的长度，直接输出false，设s1的长度为n，s2的长度为m，s3的长度为n+m，从最后一步出发，假设s3是由s1和s2交错构成的，那么s3的最后一个字符，要么是s1的最后一个字符，要么是s2的最后一个字符。这就是两种情况：</code></pre></blockquote><ul><li>如果是s1的最后一个字符，那么<code>s3[0...n+m-2]</code>是由<code>s1[0..n-2]与s2[0..m-1]</code>交错形成的</li><li>如果是s2的最后一个字符，那么<code>s3[0...n+m-2]</code>是由<code>s1[0..n-1]与s2[0..m-2]</code>交错形成的</li></ul><p>这两种情况只要一种成立即可。</p><p>【状态】<code>dp[s][i][j]</code>为s3前s个字符是否由A前i个字符<code>A[0..i-1]</code>和B前j个字符<code>B[0..j-1]</code>交错形成，这是最直观的，由于<code>s = i + j</code>，便可以开成两维，设<code>dp[i][j]</code>为s3前i+j个字符是否由A前i个字符 <code>A[0..i-1]</code>和B前j个字符<code>B[0..j-1]</code>交错形成。</p><p>【转移方程】<code>dp[i][j] = (dp[i-1] [j] &amp;&amp; s1[i] == s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j] == s3[]i+j-1)</code></p><p>【初始条件】空串本身可以由s1的空串和s2的空串交错形成，<code>dp[0][0] = true</code></p><p>【边界情况】如果i=0，不考虑情况一,因为没有s1[i-1];如果j=0，不考虑情况二，因为没有s2[j-1]</p><p>【计算顺序】</p><ul><li>f[0] [0], f[0] [1], …, f[0] [m]</li><li>f[1] [0], f[1] [1], …, f[1] [m]</li><li>……</li><li>f[n] [0], f[n] [1], …, f[n] [m]</li></ul><p>时间复杂度O(NM)，空间复杂度O(NM)，可以用滚动数组优化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isInterleave</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> s3<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> n <span class="token operator">+</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要把空串也纳入考虑</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果是s1中最后一个字符</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> s3<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//如果是s2中最后一个字符</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> s3<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、LintCode-119-Edit-Distance"><a href="#3、LintCode-119-Edit-Distance" class="headerlink" title="3、LintCode 119 Edit Distance"></a>3、<a href="http://www.lintcode.com/problem/edit-distance/" target="_blank" rel="noopener"><strong>LintCode 119 Edit Distance</strong></a></h3><p>【问题】编辑距离。给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。你总共三种操作方法：插入一个字符、删除一个字符、替换一个字符。</p><blockquote><pre class=" language-texzt"><code class="language-texzt">输入: "horse", "ros",输出: 3解释: horse -> rorse (替换 'h' 为 'r')、rorse -> rose (删除 'r')、rose -> ros (删除 'e')</code></pre></blockquote><p>【分析】要变成一模一样，一定要有个顺序的概念，不然会做起来很麻烦，比如从左往右的顺序。A长度为m，B长度为n，编辑过后A长度为n且与B的字符顺序一样。从最后一步出发，最后一步就是让A的最后一个字符变为B的最后一个字符，一共有三种操作，每种操作考虑一番，得到以下四种情况。</p><ul><li>情况一：A最后插入B[n-1]，才能转换为B，剩下要做的就是要先将A[0..m-1]（前面不动）变成B[0..n-2]</li><li>情况二：A最后一个字符替换为B[n-1]，才能转换为B，剩下要做的就是要先将A[0..m-2]变成B[0..n-2]</li><li>情况三：A删去最后一个字符，才能转换为B，剩下要做的就是要先将A[0..m-2]变成B[0..n-2]</li><li>情况四：A和B最后一个字符相等，就是要先将A[0..m-2]变成B[0..n-2]</li></ul><p>【状态】<code>dp[i][j]</code>代表A中前i个字符和B中前j个字符的最小编辑距离</p><p>【转移方程】<code>dp[i][j] = min{dp[i][j-1]+1,dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1] &amp;&amp; A[i-1] = B[j-1]}</code></p><ul><li>增加<code>dp[i][j-1]+1</code></li><li>替换<code>dp[i-1][j-1]+1</code></li><li>删除<code>dp[i-1][j]+1</code></li></ul><p>【初始条件】一个空串和一个长度为L的串的最小编辑距离是L</p><p>【计算顺序】</p><ul><li>f[0] [0], f[0] [1], …, f[0] [m]</li><li>f[1] [0], f[1] [1], …, f[1] [m]</li><li>……</li><li>f[n] [0], f[n] [1], …, f[n] [m]</li></ul><p>时间复杂度O(NM)，空间复杂度O(NM)，可以用滚动数组优化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化，空串到任意非空串的编辑距离</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-118-Distinct-Subsequences"><a href="#4、LintCode-118-Distinct-Subsequences" class="headerlink" title="4、LintCode 118 Distinct Subsequences"></a>4、<a href="http://www.lintcode.com/problem/distinct-subsequences/" target="_blank" rel="noopener"><strong>LintCode 118 Distinct Subsequences</strong></a></h3><p>【问题】给定字符串 <code>S</code> 和 <code>T</code>，计算 <code>S</code> 的所有子序列中有多少个 <code>T</code>。子序列字符串是原始字符串删除一些(或零个)字符之后得到的字符串，并且要求剩下的字符的相对位置不能改变。(比如 <code>&quot;ACE&quot;</code> 是 <code>ABCDE</code> 的一个子序列, 而 <code>&quot;AEC&quot;</code> 不是)</p><blockquote><pre class=" language-text"><code class="language-text">输入: S = "rabbbit", T = "rabbit"输出: 3解释: 你可以删除 S 中的任意一个 'b', 所以一共有 3 种方式得到 T.输入: S = "abcd", T = ""输出: 1解释: 只有删除 S 中的所有字符这一种方式得到 T</code></pre></blockquote><p>【分析】给定序列A和B，问B在A中出现多少次，可以不连续。相当于A和B的LCS是B，但这的侧重点是B。 从最后一步出发，就是B的最后一个字符，设A的长度为n，B的长度为m，有两种情况：</p><ul><li><code>B[m-1] != A[n-1]</code>，需要考虑A[0..n-2]与B[0..m-1]</li><li><code>B[m-1] = A[n-1]</code>，只需考虑A[0..n-2]与B[0..m-2]</li><li>问次数，就是考虑加法，无重复无遗漏。</li></ul><p>【转移方程】<code>dp[i][j] = dp[i-1][j] + dp[i-1][j-1] &amp;&amp; A[i-1]=B[i-1]</code></p><p>【初始条件】考虑空串</p><ul><li>若A是空串，B不是空串，B在A中出现次数为0，<code>dp[0][j] = 0</code></li><li>若B是空串，B在A中出现次数是1（A可以是空串），就是把A中的字符都删掉<code>dp[i][0] = 1</code></li></ul><p>【计算顺序】</p><ul><li>f[0] [0], f[0] [1], …, f[0] [m]</li><li>f[1] [0], f[1] [1], …, f[1] [m]</li><li>……</li><li>f[n] [0], f[n] [1], …, f[n] [m]</li></ul><p>时间复杂度O(NM)，空间复杂度O(NM)，可以用滚动数组优化成O(N)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化：若A是空串而B不是空串，则出现次数为0</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化：若B是空串，则出现次数为1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5、LintCode-154-Regular-Expression-Matching"><a href="#5、LintCode-154-Regular-Expression-Matching" class="headerlink" title="5、LintCode 154 Regular Expression Matching"></a>5、<a href="http://www.lintcode.com/problem/regular-expression-matching/" target="_blank" rel="noopener"><strong>LintCode 154 Regular Expression Matching</strong></a></h3><p>【问题】正则表达式匹配。实现支持<code>.</code>和<code>*</code>的正则表达式匹配。<code>.</code>匹配任意一个字母。<code>*</code>匹配零个或者多个前面的元素。匹配应该覆盖整个输入字符串，而不仅仅是一部分。</p><blockquote><pre class=" language-text"><code class="language-text">需要实现的函数是：bool isMatch(string s, string p)isMatch("aa","a") → falseisMatch("aa","aa") → trueisMatch("aaa","aa") → falseisMatch("aa", "a*") → trueisMatch("aa", ".*") → trueisMatch("ab", ".*") → trueisMatch("aab", "c*a*b") → true</code></pre></blockquote><p>【分析】从最后一步出发，关注最后进来的字符。假设A的长度为n，B的长度为m，关注正则表达式B的最后一个字符是谁，它有三种可能，<code>正常字符</code>、<code>*</code>、<code>.</code></p><ol><li><p>如果B的最后一个字符是<code>正常字符</code>，那就是看<code>A[n-1]</code>是否等于<code>B[m-1]</code>，相等则看<code>A[0..n-2]</code>与<code>B[0..m-2]</code>，不等则是不能匹配，break</p></li><li><p>如果B的最后一个字符是<code>.</code>，它能匹配任意字符，直接看<code>A[0..n-2]</code>与<code>B[0..m-2]</code></p></li><li><p>如果B的最后一个字符是<code>*</code>它代表<code>B[m-2]=c</code>可以重复0次或多次，它们是一个整体<code>c*</code></p><ul><li>情况一：A[n-1]是0个c，B最后两个字符废了，能否匹配取决于A[0..m-1]和B[0..n-3]是否匹配</li><li>情况二：A[n-1]是多个c中的最后一个（这种情况必须<code>A[n-1]=c</code>或者<code>c=&#39;.&#39;</code>），所以A匹配完往前挪一个，B继续匹配，因为可以匹配多个，继续看A[0..n-2]和B[0..m-1]是否匹配。</li></ul></li></ol><p>【转移方程】<code>dp[i] [j]</code>代表A的前i个和B的前j个能否匹配</p><ul><li><p>对于1和2，可以合并成一种情况<code>dp[i][j] = dp[i-1][j-1] (if A[i-1]=B[j-1] || B[j-1]=&#39;.&#39;)</code></p></li><li><p>对于3，分为不看<code>c*</code>和看<code>c*</code>两种情况</p><ul><li>不看：直接砍掉<code>dp[i][j] = dp[i][j-2]</code></li><li>看：<code>dp[i][j] = dp[i-1][j](if A[i-1]=B[j-2] || B[j-2]=&#39;.&#39;)</code></li></ul></li></ul><p>【初始条件】考虑空串空正则</p><ul><li>空串和空正则是匹配的，<code>dp[0][0] = true</code></li><li>非空串和空正则必不匹配，<code>dp[1][0]=...=dp[n][0]=false</code></li><li>空串和非空正则，不能直接定义true和false，必须要计算出来。（在1、2中不能计算，在3中<code>dp[i][j] = dp[i][j-2]</code>可能出现，比如<code>A=&quot;&quot;</code>,<code>B=a*b*c*</code>）</li><li><strong>大体上可以分为空正则和非空正则两种</strong></li></ul><p>【计算顺序】</p><ul><li>f[0] [0], f[0] [1], …, f[0] [m]</li><li>f[1] [0], f[1] [1], …, f[1] [m]</li><li>……</li><li>f[n] [0], f[n] [1], …, f[n] [m]</li></ul><p>时间复杂度O(NM)，空间复杂度O(NM)，可以用滚动数组优化成O(N)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//分为空正则与非空正则两种讨论</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//非空正则，大致分为最后一个是不是 *</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//最后一个是 * ，分为不看和看两种情况</span>                        <span class="token comment" spellcheck="true">//不看</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//看</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">||</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="6、LintCode-192-Wildcard-Matching"><a href="#6、LintCode-192-Wildcard-Matching" class="headerlink" title="6、LintCode 192 Wildcard Matching"></a>6、<a href="http://www.lintcode.com/problem/wildcard-matching/" target="_blank" rel="noopener"><strong>LintCode 192 Wildcard Matching</strong></a></h3><p>【问题】通配符匹配，上一题是正则表达式匹配。判断两个可能包含通配符<code>？</code>和<code>*</code>的字符串是否匹配。匹配规则如下：<code>?</code>可以匹配任何单个字符，<code>*</code> 可以匹配任意字符串（包括空字符串）。两个串完全匹配才算匹配成功。</p><p>【分析】通配符匹配和正则表达式匹配很像，正则表达式中的<code>.</code>与通配中的<code>?</code>作用是一样的，不同的是<code>*</code>，正则表达式中的<code>*</code>能匹配零个或者多个前面的元素，通配中的<code>*</code>能匹配0个或多个任意字符，实际上通配的情况要比正则表达式中的情况简单得多。仍然从B的最后一个字符出发，有三种可能：<code>正常字符</code>、<code>?</code>、<code>*</code>，讨论如下：（前两条情况和正则表达式一样）</p><ol><li><p>如果B的最后一个字符是<code>正常字符</code>，那就是看A[m-1]是否等于B[n-1]，相等则看A[0..m-2]与B[0..n-2]，不等则是不能匹配，break</p></li><li><p>如果B的最后一个字符是<code>？</code>，它能匹配任意字符，直接看A[0..m-2]与B[0..n-2]</p></li><li><p>如果B的最后一个字符是<code>*</code>，他能匹配0个或多个任意字符，那就分为两种情况</p><ul><li>匹配0个：就是这个<code>*</code>直接废了，需要看<code>A[0..n-1]</code>与<code>B[0..m-2]</code></li><li>匹配多个：则需要看<code>A[0..n-2]</code>与<code>B[0..m-1]</code></li></ul></li></ol><p>【转移方程】<code>dp[i] [j]</code>代表A的前i个和B的前j个能否匹配</p><ul><li>对于1和2，可以合并成一种情况<code>dp[i][j] = dp[i-1][j-1] (if A[i-1]=B[j-1] || B[j-1]=&#39;?&#39;)</code></li><li>对于3，分为不看<code>c*</code>和看<code>c*</code>两种情况<ul><li>匹配0个，就是不看，直接砍掉：<code>dp[i][j] = dp[i][j-1]</code></li><li>匹配多个：<code>dp[i][j] = dp[i-1][j](if B[j-1]=&#39;*&#39;)</code></li></ul></li></ul><p>【初始条件】<strong>大体上依旧是分为空正则和非空正则两种</strong></p><ul><li>空正则和空串匹配</li><li>空正则和非空串必不匹配</li><li>非空正则和空串需要看情况</li></ul><p>【计算顺序】</p><ul><li>f[0] [0], f[0] [1], …, f[0] [m]</li><li>f[1] [0], f[1] [1], …, f[1] [m]</li><li>……</li><li>f[n] [0], f[n] [1], …, f[n] [m]</li></ul><p>时间复杂度O(NM)，空间复杂度O(NM)，可以用滚动数组优化成O(N)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//空正则与非空正则两种情况讨论</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//分为最后一个字符是不是 * 的两种情况</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> B<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//分为匹配0个和匹配多个两种情况,这里j必定>1</span>                        <span class="token comment" spellcheck="true">//匹配0个</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="7、LintCode-668-Ones-And-Zeroes"><a href="#7、LintCode-668-Ones-And-Zeroes" class="headerlink" title="7、LintCode 668 Ones And Zeroes"></a>7、<a href="http://www.lintcode.com/en/problem/ones-and-zeroes/" target="_blank" rel="noopener"><strong>LintCode 668 Ones And Zeroes</strong></a></h3><p>【问题】假设你分别是 m个 <code>0</code> 和 n个 <code>1</code> 的统治者。 另一方面, 有一个只包含 <code>0</code> 和 <code>1</code> 的字符串构成的数组。现在你的任务是找到可以由 m个 <code>0</code> 和 n个 <code>1</code> 构成的字符串的最大个数。每一个 <code>0</code> 和 <code>1</code> 均只能使用一次</p><blockquote><pre class=" language-text"><code class="language-text">输入：["10", "0001", "111001", "1", "0"] 5 3输出：4解释：这里总共有 4 个字符串可以用 5个 0s 和 3个 1s来构成, 它们是 "10", "0001", "1", "0"。输入：["10", "0001", "111001", "1", "0"] 7 7输出：5解释：所有字符串都可以由7个 0s 和 7个 1s来构成.</code></pre></blockquote><p>【分析】如果没有0，只有1，这就相当于背包问题。这边只是多了个0，用背包思路考虑，看最后一个物品有没有进去，就是分为放和不放两种情况：</p><ul><li>情况一：不放，最后一个字符串（物品）没有进去，一共给定了T个串，那就是去看前T-1个串中，用给的0和1最多能组成多少个01串</li><li>情况二：放，最后一个字符串（物品）进去了，最后一个串中有多少个0和1，那么就在m和n中减去，比如最后一个串中有j个0，k个1，那么剩下0就是m-j，剩下1就是n-k，看这些剩下的在前T-1个串中最多能组成多少个。</li></ul><p>【转移方程】用<code>dp[i][j][k]代表前i个串最多能有多少个被j个0和k个1组成</code></p><ul><li><code>dp[i][j][k] = max{dp[i-1][j][k],dp[i-1][j-a][k-b]}</code>，a代表放的这个01串中0的个数，b代表放的这个01串中1的个数。</li></ul><p>【转移方程】前0个串，最多组成0个</p><ul><li><code>f[0][0~m][0~n] = 0</code></li></ul><p>【答案】<code>dp[T][m][n]</code>，len为字符串的个数</p><p>时间复杂度:O(Tmn)，空间复杂度:O(Tmn)，可以用滚动数组优化至 O(mn)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaxForm</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//不放</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//放</span>                    String s <span class="token operator">=</span> strs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> count0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            count0<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            count1<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> count0 <span class="token operator">&amp;&amp;</span> k <span class="token operator">>=</span> count1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> count0<span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> count1<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>滚动数组优化，当前的i之和前一个i-1有关联，空间复杂度O(mn)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaxForm</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//不放</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//放</span>                    String s <span class="token operator">=</span> strs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> count0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            count0<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            count1<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> count0 <span class="token operator">&amp;&amp;</span> k <span class="token operator">>=</span> count1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> count0<span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> count1<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/02/%E5%8D%9A%E5%BC%88%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/02/%E5%8D%9A%E5%BC%88%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划：博弈型"><a href="#动态规划：博弈型" class="headerlink" title="动态规划：博弈型"></a>动态规划：博弈型</h2><p><strong>博弈型dp一般从第一步分析，而不是最后一步，需要开n+1</strong></p><h3 id="1、LintCode-394-Coins-in-a-Line"><a href="#1、LintCode-394-Coins-in-a-Line" class="headerlink" title="1、LintCode 394 Coins in a Line"></a>1、<a href="https://www.lintcode.com/problem/coins-in-a-line/description" target="_blank" rel="noopener"><strong>LintCode 394 Coins in a Line</strong></a></h3><p>【问题】有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。请判定 先手玩家必胜还是必败?</p><p>【分析】从第一步开始，一开始有n个硬币，A可以拿一个或两个硬币，这样B则对应拿n-1个或n-2个硬币，A肯定会采取策略让自己获胜。然后不断拿。假设一开始有5个硬币，可以画出如果所示的树形结构，必败就是自己无路可逃，必胜就是有赢的可能。</p><p><img src="https://img-blog.csdnimg.cn/20191208001202224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3HH8MNpW-1575735100624)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191207201606034.png)\]"></p><p>【状态】设dp[i]表示面对i个硬币，是否先手必胜则有下面几种情况</p><ul><li><code>dp[i] = true，f[i-1]==false || f[i-2]==false</code>（对手拿1个或2个都是必败的情况）</li><li><code>dp[i] = false，f[i-1]==true &amp;&amp; f[i-2]==true</code>（对手拿1个或2个都是必胜的情况）</li></ul><p>【初始情况与边界】</p><ul><li><code>dp[0] = 0</code>，面对0个硬币，必败</li><li><code>dp[1] = dp[2] = true</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">firstWillWin</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// if (dp[i - 1] == true &amp;&amp; dp[i - 2] == true) {</span>            <span class="token comment" spellcheck="true">//     dp[i] = false;</span>            <span class="token comment" spellcheck="true">// } else {</span>            <span class="token comment" spellcheck="true">//     dp[i] = true;</span>            <span class="token comment" spellcheck="true">// }</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">!</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划</title>
      <link href="/2019/12/02/%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/12/02/%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划解题模版：：坐标型"><a href="#动态规划解题模版：：坐标型" class="headerlink" title="动态规划解题模版：：坐标型"></a>动态规划解题模版：：坐标型</h2><p>坐标型dp一般都是给定网格、序列，来求满足某种性质的最大值、最小值。开数组时，<code>f[i]</code>代表以a<del>i</del> 结尾的满足条件的子序列，<code>f[i][j]</code>代表以i、j结尾的满足条件的某种情况。</p><p>做题思路：</p><ul><li>从最后一步出发思考，确定状态</li><li>分析子问题是什么</li><li>得到状态转移方程</li><li>确定初始条件与边界条件</li><li>编程</li></ul><h3 id="1、Lintcode-114-UniquePaths"><a href="#1、Lintcode-114-UniquePaths" class="headerlink" title="1、Lintcode 114 UniquePaths"></a>1、<a href="https://www.lintcode.com/problem/unique-paths/" target="_blank" rel="noopener">Lintcode 114 UniquePaths</a></h3><p>【问题】有一个机器人的位于一个 <code>m × n</code>个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。问有多少条不同的路径？</p><p>【分析】最后一步：要么从左边来，要么从上边来，故<code>dp[i][j] = dp[i][j-1] + dp[i-1][j]</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第一行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化第一列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//处理其他</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、Lintcode-115-UniquePathsWithObstacles"><a href="#2、Lintcode-115-UniquePathsWithObstacles" class="headerlink" title="2、Lintcode 115 UniquePathsWithObstacles"></a>2、<a href="https://www.lintcode.com/problem/unique-paths-ii/" target="_blank" rel="noopener">Lintcode 115 UniquePathsWithObstacles</a></h3><p>【问题】上一题的跟进问题，现在考虑网格中有障碍物，那样将会有多少条不同的路径？网格中的障碍和空位置分别用 1 和 0 来表示。</p><p>【分析】从最后一步出发，要选一条没有障碍的路径到达右下角，当前位置i,j所有可能路径依然是 <code>dp[i] [j] = dp[i] [j-1] + dp[i-1] [j]</code>，但必须是没有障碍的</p><ul><li>起点和终点若有障碍，直接返回0</li><li>初始化第一行和第一列，也要考虑有障碍的情况</li><li>起点和终点没有障碍，若途中碰到障碍了，令<code>dp[i][j] = 0</code>，表示不可达</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断起点和终点有没有障碍，有障碍直接返回0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> A<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第一行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//初始化第一列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//处理其他</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3、Lintcode-397-Longest-Increasing-Continuous-Subsequence"><a href="#3、Lintcode-397-Longest-Increasing-Continuous-Subsequence" class="headerlink" title="3、Lintcode 397 Longest Increasing Continuous Subsequence"></a>3、<a href="http://www.lintcode.com/en/problem/longest-increasing-continuous-subsequence/" target="_blank" rel="noopener">Lintcode 397 Longest Increasing Continuous Subsequence</a></h3><p>【问题】给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p><p>【分析】也就是求“最长连续单调子序列”，也就是LIS+LDS。实际上只要求个LIS再倒过来求一遍。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestIncreasingContinuousSubsequence</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">LIS</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//倒过来求一遍</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> A<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">LIS</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">LIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//最少长度是1</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//长度至少是1，它本身</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="4、LintCode-110-Minimum-Path-Sum"><a href="#4、LintCode-110-Minimum-Path-Sum" class="headerlink" title="4、LintCode 110 Minimum Path Sum"></a>4、<a href="http://www.lintcode.com/problem/minimum-path-sum/" target="_blank" rel="noopener">LintCode 110 Minimum Path Sum</a></h3><p>【问题】给定一个只含非负整数的<code>m x n</code>网格，找到一条从左上角到右下角的可以使数字和最小的路径。简而言之求最小路径和。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//普通方式</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//来自上方的情况</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//来自左侧的情况</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>使用滚动数组进行优化，当前行只和上面一行有关系，实际上只需要开两行，使用<code>old</code>和<code>new</code>指针，old存放i-1行，new存放当前第i行，关键语句在于old和now进行交换</p><blockquote><p>old = now;</p><p>now = 1 - now</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//滚动数组优化</span><span class="token comment" spellcheck="true">//只需要把i变为now，i-1变为old即可</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            now <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//来自上方</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>old<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//来自左侧</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20191208000116507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5、LintCode-553-Bomb-Enemy"><a href="#5、LintCode-553-Bomb-Enemy" class="headerlink" title="5、LintCode 553 Bomb Enemy"></a>5、<a href="https://www.lintcode.com/problem/bomb-enemy/description" target="_blank" rel="noopener">LintCode 553 Bomb Enemy</a></h3><p>【问题】给定一个二维矩阵, 每一个格子可能是一堵墙 <code>W</code>,或者 一个敌人 <code>E</code> 或者空 <code>0</code> (数字 ‘0’), 返回你可以用一个炸弹杀死的最大敌人数. 炸弹会杀死所有在同一行和同一列没有墙阻隔的敌人。 由于墙比较坚固，所以墙不会被摧毁。</p><p>【分析】原本只能在空地放炸弹，现在假设有敌人和有墙的地方也能放炸弹，有敌人的地方，格子里的敌人能被炸死，再加上其他炸死的人，有墙的地方，炸死人数为0。现在分析一个方向，比如向上，有三种情况：</p><ul><li>（i,j）是空地：结果就是从（i-1,j）格开始向上能炸死的敌人数</li><li>（i,j）是敌人：结果就是从（i-1,j）格开始向上能炸死的敌人数 + 1</li><li>（i,j）是墙：0</li></ul><p>原来要求（i,j）格子放炸弹向上能炸死的敌人数，子问题就转化为（i-1,j）格向上能炸死的敌人数，上述三种情况就如下：</p><ul><li><code>Up[i][j] = Up[i-1][j]</code>，(i,j)是空地的情况</li><li><code>Up[i][j] = Up[i-1][j] + 1</code>，(i,j)是敌人的情况</li><li><code>Up[i][j] = 0</code>，(i,j)是墙的情况</li></ul><p>初始条件就是第0行，如果是敌人，向上炸死人数为1，如果是空地或墙，向上炸死人数为0。</p><p>另外三个方向<code>Down[i][j], Left[i][j], Right[i][j]</code>也是一样考虑。炸死的敌人数就是四个方向加起来，每次更新一下最大值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maxKilledEnemies</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>grid <span class="token operator">==</span> null <span class="token operator">||</span> grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> up <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> down <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//i,j处为炸弹放置的位置</span>                <span class="token comment" spellcheck="true">//如果是墙,其实四种情况都是0</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'W'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> up<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//down应该从下往上算，自底向上</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'W'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> down<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//left，从左往右算</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'W'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//right，从右往左算</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'W'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//结果填充dp</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//只有在空地能放炸弹</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2019/11/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A4%96%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/11/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A4%96%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="海量数据处理（4）：外排序算法"><a href="#海量数据处理（4）：外排序算法" class="headerlink" title="海量数据处理（4）：外排序算法"></a>海量数据处理（4）：外排序算法</h1><h2 id="一、外排序算法"><a href="#一、外排序算法" class="headerlink" title="一、外排序算法"></a>一、外排序算法</h2><p>外排序算法是指能够处理极大量数据的排序算法。通常来说，<strong>外排序处理的数据不能一次装入内存，只能放在硬盘上</strong>。通常采用<strong>排序–归并</strong>的策略，将原本的大文件，拆分为若干个小文件，小文件可以读入内存中进行排序，然后使用归并操作。</p><p>因此，外排序通常分为两个基本步骤：</p><ul><li>大文件拆分成若干个小的，并分别使用内存排好序</li><li>使用K路归并算法将若干个排好序的小文件合并到一个大文件中</li></ul><h3 id="1、文件拆分"><a href="#1、文件拆分" class="headerlink" title="1、文件拆分"></a>1、文件拆分</h3><p>根据内存的大小，尽可能多的分批次的将数据 Load 到内存中，并使用系统自带的内存排序函数（或者自己写个快排），将其排好序，并输出到一个个小文件中。比如一个文件有1T，内存有1G（自己设置jvm参数），那么我们就这个大文件中的内容按照 1G 的大小，分批次的导入内存，排序之后输出得到 1024 个 1G 的小文件。</p><h3 id="2、K路归并"><a href="#2、K路归并" class="headerlink" title="2、K路归并"></a>2、K路归并</h3><p>小文件都排完序后，就使用K路归并算法合并排序好的文件。K路归并使用的是<strong>堆</strong>来完成的。我们将 K 个文件中的第一个元素加入到堆里，假设数据是从小到大排序的话，那么这个堆是一个最小堆（Min Heap）。每次从堆中选出最小的元素，输出到目标结果文件中，然后如果这个元素来自第 x 个文件，则从第 x 个文件中继续读入一个新的数进来放到堆里，并重复上述操作，直到所有元素都被输出到目标结果文件中。</p><p><strong>其实这个思路就是和合并K个排序链表/有序数组是一样的，leetcode有这个题的，当时就是用堆来做。</strong></p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCode 23.合并K个排序链表</a></p><p>这边一个问题是在归并的过程中，一个个从文件中读入数据，一个个输出到目标文件中操作很慢，如何优化？如果我们每个文件只读入1个元素并放入堆里的话，总共只用到了 1024 个元素，这很小，没有充分的利用好内存。另外，单个读入和单个输出的方式也不是磁盘的高效使用方式。<strong>因此我们可以为输入和输出都分别加入一个Buffer</strong>。假如一个元素有10个字节大小的话，1024 个元素一共 10K，1G的内存可以支持约 100K 组这样的数据，那么我们就为每个文件设置一个 100K 大小的 Buffer，每次需要从某个文件中读数据，都将这个 Buffer 装满。当然 Buffer 中的数据都用完的时候，再批量的从文件中读入。输出同理，设置一个 Buffer 来避免单个输出带来的效率缓慢。</p><p><strong>总之就是加一个Buffer来改善性能，具体设置多大得看实际情况啦。</strong></p><h2 id="二、求两个超大文件中-URLs-的交集"><a href="#二、求两个超大文件中-URLs-的交集" class="headerlink" title="二、求两个超大文件中 URLs 的交集"></a>二、求两个超大文件中 URLs 的交集</h2><p>问题的具体描述如下：给定A、B两个文件，各存放50亿个URLs，每个 URL 各占 64 字节，内存限制是 4G，让你找出A、B文件共同的 URLs？</p><p>遇到问题首先还是要看有没有条件需要澄清，这里主要是一个问题：这两个文件各自是否已经没有重复？<br>对于这个问题，通常面试官会先让你假设没有重复，然后再来看有重复的情况怎么处理。</p><h3 id="方法1：文件拆分"><a href="#方法1：文件拆分" class="headerlink" title="方法1：文件拆分"></a>方法1：文件拆分</h3><p>文件拆分可以叫sharding，也可以叫partition，这是能想到的最简单的方法，肯定就是要把文件从拆分，思路来源于kafka、es。50亿，每个 URLs 64 字节，也就是 320G 大小的文件。很显然我们不能直接全部 Load 到内存中去处理。这种内存不够的问题，通常我们的解决方法都可以是使用 hash function 来将大文件拆分为若干个小文件。比如按照hashfunc(url) % 200进行拆分的话，可以拆分成为，200 个小文件（就是如果 hashfunc(url) % 200 = 1 就把这个 url 放到 1 号文件里）每个小文件理想状况下，大小约是 1.6 G，完全可以 Load 到内存里。</p><p>这种方法的好处在于，因为我们的目标是要去重，那么那些A和B中重复的 URLs，会被hashfunc(url) % 200映射到同一个文件中。这样在这个小文件中，来自 A 和 B 的 URls 在理想状况下一共 3.2G，可以全部导入内存进入重复判断筛选出有重复的 URLs。</p><p>但如果 hashfunc(url) % 200 的结果比较集中，就有可能会造成不同的 URLs 在同一个文件中扎堆的情况，这种情况下，有一些文件的大小可能会超过 4G。对于这种情况，处理的办法是进行二次拆分，把这些仍然比较大的小文件，用一个新的 hashfunc 进行拆分：hashfunc’(url) % X。这里再拆成多少个文件，可以根据文件的实际大小来定。如果二次拆分之后还是存在很大的文件，就进行三次拆分。直到每个小文件都小于 4G。</p><h3 id="方法2：BloomFilter"><a href="#方法2：BloomFilter" class="headerlink" title="方法2：BloomFilter"></a>方法2：BloomFilter</h3><p>既然是内存空间太少的问题，有一个主要用于内存过少的情况的数据结构：BloomFilter。我们可以使用一个 4G 的 Bloom Filter，它大概包含 320 亿 个 bit（1G = 2^30^ * 8 bit）。把 A 文件的 50亿 个 URLs 丢入 BF 中，然后查询 B 文件的 每个 URL 是否在 BF 里。这种方法的缺点在于，320 亿个 bit 的 BF 里存 50 亿个 URLs 实在是太满了（要考虑到BF可能会用4个哈希函数），错误率会很高。因此仍然还需需要方法1中的文件拆分来分批处理。</p><h3 id="方法3：外排序算法"><a href="#方法3：外排序算法" class="headerlink" title="方法3：外排序算法"></a>方法3：外排序算法</h3><p>将A,B文件分别拆分为80个小文件，每个小文件4G。每个文件在拆分的时候，每4G的数据在内存中做快速排序并将有序的URLs输出到小文件中。用多路归并算法，将这些小文件进行归并，在归并的过程中，即可知道哪些是重复的 URLs。只需将重复的 URLs 记录下来即可。</p><p>当 A, B 各自有重复的 URLs 的时候，比如最坏情况下，A里的50亿个URLs 全部一样。B里也是。这样采用方法1这种比较容易想到的 Sharding 方法，是不奏效的，因为所有 URLs 的 hashcode 都一样，就算换不同的 hashfunc 也一样。这种情况下，需要先对两个文件进行单独的去重，方法是每 4G 的数据，放到内存中用简单的哈希表进行去重。这样，在最坏情况下，总共 320G 的数据里，一个 URLs 最多重复 80次，则不会出现太严重的扎堆情况了。算法上唯一需要稍微改动的地方是，由于 A 存在多个重复的 URLs，所以当和 B 的 URLs 被sharding 到同一个文件里的时候，需要标记一下这个 URLs 来自哪个文件，这样才能知道是否在A和B中同时出现过。<br>另外，<strong>使用外排序的方法，是无需对两个文件进行单独去重的步骤的。</strong></p><p>总结：用外排序，分治思想，采用哈希函数，外排在归并的时候看一下有没有重复，不用提前去重。</p>]]></content>
      
      
      <categories>
          
          <category> 海量数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海量数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2019/11/24/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/11/24/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="海量数据处理（3）：布隆过滤器"><a href="#海量数据处理（3）：布隆过滤器" class="headerlink" title="海量数据处理（3）：布隆过滤器"></a>海量数据处理（3）：布隆过滤器</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>布隆过滤器（Bloom Filter，BF）对普通的哈希表做了进一步的改进，是一种更省空间的哈希表。当碰到内存不够的问题时，BF就是一个很好的选择。BF的两个功能：检测一个元素在不在一个集合中、统计一个元素的出现次数（实际上就是map的作用）。</p><p>BF虽然节省了空间，但同样也有一个副作用，即存在 <strong>False Positive（正误识）</strong>。 简单的说就是，如果是 Hash 的话，他说这个元素在集合里，那就是在集合里。而如果是 BF 的话，他说在集合里，你别当真，有一定概率这个元素不在集合里。也就是说 BF 会给出一个错误的（False）肯定（Positive）。</p><p>一个更完整的BloomFilter会包含以下两个部分：</p><ul><li>k 个完全独立的哈希函数</li><li>一个很大的数组</li></ul><p>根据处理的问题的不同，BloomFilter可以分为：</p><ul><li>标准型布隆过滤器（Standard Bloom Filter， SBF，相当于 HashSet）</li><li>计数型布隆过滤器（Counting Bloom Filter， CBF，相当于 HashMap）</li></ul><p>对于 SBF，其包含的大数组的类型为 Boolean 类型。对于 CBF，其包含的大数组的类型为整数类型。</p><p>最常见的hash函数如下</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 这个算法，相当于把一个字符串当做了 31 进制，然后转换为整数。一边转换的过程中一边对 hashsize 取模，避免溢出。</span><span class="token comment" spellcheck="true"># 要设计k个完全独立的hash函数，只要把31改成其他素数如37、41等。尽量不要合数，会增加哈希冲突概率</span><span class="token keyword">def</span> <span class="token function">hashfunc</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> hashsize<span class="token punctuation">)</span><span class="token punctuation">:</span>    code <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> c <span class="token keyword">in</span> string<span class="token punctuation">:</span>        code <span class="token operator">=</span> code <span class="token operator">*</span> <span class="token number">31</span> <span class="token operator">+</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        code <span class="token operator">=</span> code <span class="token operator">%</span> hashsize    <span class="token keyword">return</span> code</code></pre><h2 id="二、实现标准布隆过滤器"><a href="#二、实现标准布隆过滤器" class="headerlink" title="二、实现标准布隆过滤器"></a>二、实现标准布隆过滤器</h2><p>SBF相当于HashSet，支持添加元素以及判断一个元素是否在集合中。（允许 False Positive）</p><p>实现：</p><ul><li>初始化：开一个足够大的 boolean 数组，初始值都是 false。</li><li>插入一个元素：通过 k 个哈希函数，计算出元素的 k 个哈希值，对 boolean 数组的长度取模之后，标记对应的 k 个位置上的值为 true。</li><li>查询一个元素：通过同样的 k 哈希函数，在 boolean 数组中取出对应的 k 个位置上的值。如果都是 true，则表示该元素可能存在，如果有一个 false，则表示一定不存在。</li></ul><p><a href="https://www.lintcode.com/problem/standard-bloom-filter/description" target="_blank" rel="noopener">LintCode 556. Standard Bloom Filter</a></p><p>在这边使用了BitSet，它是Java中的一种数据结构。主要存储的是二进制位，每一位只用来存储0，1值，0代表false，1代表true。0表示该数据没有出现过，1表示出现过。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardBloomFilter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> BitSet bitSet<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>HashFunction<span class="token operator">></span> hashFunctions<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法, 创建k个hash方法</span>    <span class="token keyword">public</span> <span class="token function">StandardBloomFilter</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>        hashFunctions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            hashFunctions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashFunction</span><span class="token punctuation">(</span><span class="token number">100000</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bitSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitSet</span><span class="token punctuation">(</span><span class="token number">100000</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//MOD有多大，bitSet就要有多少个位</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @param word     * 往布隆过滤器中加入一个字符串     * 用每个hash函数计算下hash值，得到了hash值就得到了在bitSet中对应的位，并将对应的位置成true（1）     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> hashFunctions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            bitSet<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//检查字符串是否在过滤器中</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> hashFunctions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果有一处为false(0)，那就return false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bitSet<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//包装成类，每一个对象就是不同的hash函数</span><span class="token keyword">class</span> <span class="token class-name">HashFunction</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> MOD<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//MOD即基数，用于取模</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> seed<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//seed相当于进制</span>    <span class="token keyword">public</span> <span class="token function">HashFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> MOD<span class="token punctuation">,</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>MOD <span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>seed <span class="token operator">=</span> seed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+=</span> res <span class="token operator">*</span> seed <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">%=</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="三、实现计数型布隆过滤器"><a href="#三、实现计数型布隆过滤器" class="headerlink" title="三、实现计数型布隆过滤器"></a>三、实现计数型布隆过滤器</h2><p>对SBF稍作改动，把存储所用的 boolean 数组改为 int 数组，就成为了可以计数的布隆过滤器。这个数据结构类似 Java 中的 HashMap，但只能用作计数。支持添加元素以及统计某个元素在该集合中出现的次数，统计的次数可能会比实际出现次数要大一些。</p><p>实现：</p><ul><li>初始化：开一个足够大的 int 数组，初始值都是 0。</li><li>插入一个元素：通过 k 个哈希函数，计算出元素的 k 个哈希值，对 int 数组的长度取模之后，将对应的 k 个位置上的值都加一。</li><li>查询一个元素的出现次数：通过同样的 k 哈希函数，在 int 数组中取出对应的 k 个位置上的值。并取其中的最小值来作为该元素的出现次数预估。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountingBloomFilter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bits<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>HashFunction<span class="token operator">></span> hashFunctions<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CountingBloomFilter</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>        hashFunctions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            hashFunctions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashFunction</span><span class="token punctuation">(</span><span class="token number">100000</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bits <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">100000</span> <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//MOD最大值即可</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 往布隆过滤器中加入一个字符串</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> hashFunctions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            bits<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从布隆计数器中删除一个字符串</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> hashFunctions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            bits<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这边改一下即可</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 检查一个字符串是否在布隆过滤器中</span>    <span class="token comment" spellcheck="true">// 需要得到最小的次数（虽然可能依旧偏大），如果存在最小的次数为0，那这个字符串必不存在于CBF中</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> hashFunctions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bits<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">HashFunction</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> MOD<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//MOD即基数，用于取模</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> seed<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//seed相当于进制</span>    <span class="token keyword">public</span> <span class="token function">HashFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> MOD<span class="token punctuation">,</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>MOD <span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>seed <span class="token operator">=</span> seed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+=</span> res <span class="token operator">*</span> seed <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">%=</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 海量数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海量数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2019/11/22/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BTopK%E9%97%AE%E9%A2%98/"/>
      <url>/2019/11/22/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BTopK%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="海量数据处理（2）：最高频K项问题"><a href="#海量数据处理（2）：最高频K项问题" class="headerlink" title="海量数据处理（2）：最高频K项问题"></a>海量数据处理（2）：最高频K项问题</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>这个问题即：找到一个大文件或者数据流中出现频率最高的 K 项。问题的难点在于，如果条件不一样，解决的办法是完全不一样的，比如：</p><ul><li>是否需要<strong>精确</strong>的 Top K 结果？即，是否允许小概率出错。</li><li>数据是<strong>离线的</strong>还是<strong>在线的</strong>？即是一个大文件的形式计算一次得到一个结果，还是数据流的形式实时返回结果。</li></ul><p>如果对于一个大文件（也就是说离线的），只是简单的找到前k大的，使用<code>quick select</code>算法即可。在线数据流如何处理？很简单，只要拿新加进来的数和前k大中的最后一个个数比较即可，新来的比它大，那就把最后一个踢出。问题就转变为集合中维护最小的数，马上就想到了<code>min heap</code>。</p><blockquote><p>离线问题—-&gt;quick select算法</p><p>在线问题—-&gt;维护minHeap</p></blockquote><p><a href="https://www.lintcode.com/problem/top-k-largest-numbers-ii/description" target="_blank" rel="noopener">LintCode 545. Top K Largest Numbers</a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>        <span class="token keyword">private</span> Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minHeap<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>            minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minHeap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    minHeap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="二、离线处理-Top-K问题"><a href="#二、离线处理-Top-K问题" class="headerlink" title="二、离线处理 Top K问题"></a>二、离线处理 Top K问题</h2><p><strong>离线问题</strong>的主要处理步骤是</p><ol><li>首先用hash表统计所有项的出现次数</li><li>寻遍每一个出现过的项，用最大K项的方法，获得最大的前K项</li></ol><h3 id="1、MapReduce处理离线-Top-K-步骤"><a href="#1、MapReduce处理离线-Top-K-步骤" class="headerlink" title="1、MapReduce处理离线 Top K 步骤"></a>1、MapReduce处理离线 Top K 步骤</h3><ol><li>通过 Map 步骤，将每一个文件中的单词一个个取出，每个单词构造一个 &lt;Word, 1&gt; 的 Key-value 二元组，作为 Map 的输出。</li><li>通过 Reduce 的步骤，每台机器（Reducer）会处理若干个不同的 Key，在每个 Reducer 一开始初始化的时候，构建一个最小堆，输入 key（某个 word） 和他对应的values（可以假设 values 就是一堆 1，事实上 Map Reduce 会帮你做一些优化，导致有可能 value 已经被加过，所以实际处理的时候，还是老老实实的把 values 加起来，而不是看一下 values 有多少个）。那么我们把所有的 values 加起来就是当前这个 key（某个 word）的出现次数。那么当我们拿到这个单词的出现次数之后，就可以在当前的 Reducer 里去和最小堆里的第K大比大小，来决定是否淘汰当前的第K大了。Reducer 在处理完他需要处理的数据之后，就输出他得到的 Top K。</li><li>由于有多个 Reducers，因此我们会得到多个 Top K，最后还需要从这些输出中过一遍，得到最终的 Top K。这个步骤已经在 Map Reduce 之外了，用一个单独的代码扫一遍就可以了。</li></ol><p><strong>实际情况下，如果真的是非常庞大的数据，全表扫描的时间消耗很长，而且把所有数据放到内存中，这个做法依旧不可行，即使用了MapReduce，用了很多台机器，具体分配到每台机器，也可能出现无法全部加载到内存的情况，我们不能一碰到情况就加机器。</strong></p><p><strong>那就是面试官问：假设现在只有一台机器，内存为 1G，你有一个 1T 大小的文件，需要统计里面最高频的 K 个单词，你该怎么做？</strong></p><p>答案是：哈希算法</p><h3 id="2、Hash算法"><a href="#2、Hash算法" class="headerlink" title="2、Hash算法"></a>2、Hash算法</h3><p>哈希函数对于同一个 Key，会返回一个<strong>固定的</strong>，无规律的整数值。虽然哈希值是可能<strong>重复的</strong>，并不是一对一的，但并不影响我们的计算。这样我们处理离线问题就分成了下面这三步：</p><ol><li>先将文件扫描一次，把每个单词作为 Key，算一下他的哈希值，然后模上大概 <strong>2000 - 10000</strong> 的这样一个数。之所以取这这么一个数是因为，内存的大小是 1G，那么如果将 1T 的文件分成若干个 1G 大小的小文件的话，那么理想需要 1000 个文件（1024G/1G）。平均下来就是将所有的单词分成 1000 组，每组大概就是 1G 个不同的单词（理想状况），实际上处理的时候，分成 2000 组比较保险。10000 组当然更保险了，但是可能就没有合理利用上内存了。实际做的时候，可以先看一下分成 2000 行不行，不行的话，再放大分组数。</li><li>对于每个文件，分别导入内存进行处理，使用<strong>哈希表+最小堆</strong>（MapReduce那块）。每一组文件得到一个 Top K。</li><li>类似于 Map Reduce 一样，我们得到了若干个 Top K，我们最后把这若干个 Top K 再合并一次就好了。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcm9wc2lyajMxaXEwdTBuM2QuanBn?x-oss-process=image/format,png" alt="image-20200109154510548"></p><h2 id="三、在线处理-Top-K-问题"><a href="#三、在线处理-Top-K-问题" class="headerlink" title="三、在线处理 Top K 问题"></a>三、在线处理 Top K 问题</h2><p>数据流问题的特点是没有第二次从头访问数据的机会。因此在离线算法中，先通过哈希表（HashMap）计数，再通过堆（Heap）来统计Top K的方法就行不通了。那在线算法的思路就是<strong>边计数，边比较Top K</strong>。这种算法的空间复杂度消耗和数据流中流过的数据量总大小有关，如果数据量一大，根本不好控制内存消耗。想要找一个在线的、精确的、省空间的TOP K算法是很困难的，只能牺牲掉准确性，<strong>用精度换空间</strong>。这就是我们优化的余地。（就好比热搜TOP 10里面 排名不用非常精确）</p><p>常见的精度换空间算法有：Lossy Counting、Efficient Count、Hash Count等</p><h3 id="1、HashCount"><a href="#1、HashCount" class="headerlink" title="1、HashCount"></a>1、HashCount</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TopKAnalyzer</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>k <span class="token operator">=</span> k        self<span class="token punctuation">.</span>hash_heap <span class="token operator">=</span> HashHeap<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>hash_count <span class="token operator">=</span> 开一个数组，内存有多大开多大    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>        index <span class="token operator">=</span> hashfunc<span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token operator">%</span> self<span class="token punctuation">.</span>hash_count<span class="token punctuation">.</span>size        self<span class="token punctuation">.</span>hash_count<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>        word_count <span class="token operator">=</span> self<span class="token punctuation">.</span>hash_count<span class="token punctuation">[</span>index<span class="token punctuation">]</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">def</span> <span class="token function">topk</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>这里将原本记录所有单词的出现次数的哈希表，换成了一个根据内存大小能开多大开多大的数组。这个数组的每个下标存储了“某些”单词的出现次数。使用了hashfun函数计算每个单词的hashcode，将hashcode模整个hashcount数组的大小得到一个下标（index），用这个下标对应的计数来代表这个单词的出现次数。有了这个单词的出现次数之后，再拿去 hash heap 里进行比较就可以了。</p><p>问题是如果有两个单词，计算下来的index一样，一个单词把另一个单词挤掉了，实际上根据<strong>长尾效应</strong>（统计学名词。正态曲线中间的突起部分叫头，两边相对平缓的部分叫尾，人们需求的角度来看，大多数的需求会集中在头部，分布在尾部的只是少量个性化的需求），由于 Top K 的 K 肯定是远小于 N（整个数据集的），而 Top K 的这些数据项的计数又远远大于其他的数据项。因此，Top K 的 index 扎堆的可能性是非常非常小的。</p><h2 id="四、面试问题"><a href="#四、面试问题" class="headerlink" title="四、面试问题"></a>四、面试问题</h2><h3 id="1、设计一个听歌统计系统，返回用户-7-天内听的最多-10-首的歌。"><a href="#1、设计一个听歌统计系统，返回用户-7-天内听的最多-10-首的歌。" class="headerlink" title="1、设计一个听歌统计系统，返回用户 7 天内听的最多 10 首的歌。"></a>1、设计一个听歌统计系统，返回用户 7 天内听的最多 10 首的歌。</h3><h4 id="（1）问题分析"><a href="#（1）问题分析" class="headerlink" title="（1）问题分析"></a>（1）问题分析</h4><p>几个问题条件：</p><ul><li>7天和10首歌这个数字是固定的么？有可能一会儿7天一会儿10天，一会儿10首歌一会儿8首歌么？</li><li>对实时性要求严格么？是否允许一定时间的延迟？比如一首个一分钟内被点爆，是否需要在这1分钟之内在榜单中体现出来？</li></ul><p>澄清问题是面试中重要的一个步骤，因为上述问题的答案，稍有不同，则算法的设计，系统的设计就截然不同。我们先做如下的合理假设：</p><ul><li>7天10首歌这两个数字是固定的。</li><li>对实时性要求不严格，可以有1小时的误差。</li></ul><h4 id="（2）离线算法"><a href="#（2）离线算法" class="headerlink" title="（2）离线算法"></a>（2）离线算法</h4><p>通常来说，系统都会进行一些 log。比如用户在什么时候听了什么歌曲，都会被作为一条条的log 记录下来，这个时候，我们可以每小时运行一次分析程序，计算最近7天被听的最多的10首歌。这个分析程序则读取最近 7 天的听歌记录，用前面的 Hash + Heap 的方法进行统计即可。如果这个记录过大，需要加速的话，还可以使用 Map Reduce 来提速。</p><ul><li><p><strong>缺点：</strong></p><ul><li>每小时都进行一次对前7天的数据统计，若数据量很大，使用 Map Reduce 则会耗费很多计算资源。</li><li>如果系统的实时性要求变高，则该方法很有可能不奏效</li></ul></li><li><p><strong>解决方案：提出基于桶（Bucket）的统计方法</strong></p><ul><li><strong>聚合（Aggregate）</strong>：将用户的同个记录，按照1小时为单位进行一次聚合（Aggregate），即整合成一个 Hash 表，Key是歌曲的id，Value是歌曲在这1小时之内被播放的次数。这种方法的好处在于，因为很多歌曲，特别是热门歌曲，是被高频率点播的，这个时候没有必要去一条一条的记录点播记录，只需要记录一个1小时的统计即可。这里每个小时就是一个桶（Bucket），比如当前时刻是 1月1日的18点，那么18点之后，19点之前的点播记录，都放在18点的这个桶里，进行聚合统计。</li><li><strong>滑动窗口（Sliding Window）</strong>：7天的话，只需要在内存中保存 7 * 24 = 144 个桶，随着时间轴的推移，旧的桶则可以被删除。每次需要获得 Top 10 的时候，则将这 144 个桶的结果进行合并即可。</li></ul></li><li><p><strong>关于桶的问题</strong></p><ul><li>如果桶统计的hash表很大，无法放进能存，那么在每个桶的局部统计中，可以删除value很小的key（长尾理论），他们都没用，但却占据了很大的空间</li><li>桶是同事存放在内存和硬盘的，存在内存中是为了更快计算top10，存在硬盘中，防止断电，并且即便桶里的数据没被存下来，可以利用数据库中的log，重新还原每个桶里的hash表</li></ul></li></ul><h4 id="（3）在线算法"><a href="#（3）在线算法" class="headerlink" title="（3）在线算法"></a>（3）在线算法</h4><p>由于有7天这个窗口，我们要做到：</p><ul><li>新数据来的时候，需要丢弃对应的7天前的旧数据。</li><li>7天之内的数据，都应该按照某种带着时间标记的方式被保存下来，而不是只有一个计数。</li><li>在线 Hash + Heap 的方法“可能”不再奏效，因为跌出前10名的歌曲，还可能在过短时间后回到前10名。而之前介绍中我们在 Heap 中保存的是前10名，跌出前10名的元素不再有机会回到前10名，则无需保存。</li></ul><h3 id="2、在-10-亿个数中找最小的-100-万个数（假设内存只能放下-100-万个数）"><a href="#2、在-10-亿个数中找最小的-100-万个数（假设内存只能放下-100-万个数）" class="headerlink" title="2、在 10 亿个数中找最小的 100 万个数（假设内存只能放下 100 万个数）"></a>2、在 10 亿个数中找最小的 100 万个数（假设内存只能放下 100 万个数）</h3><p>使用一个最大堆保存最小的前 100 万个数。循环每个数的过程中，和 Max Heap 的堆顶比较，看看是否能被加入最小前 100 万个数里。可以结合MapReduce以及HashCount算法来讲。</p>]]></content>
      
      
      <categories>
          
          <category> 海量数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海量数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2019/11/21/%E6%B5%B7%E9%87%8F%E5%A4%84%E7%90%86%E4%B9%8BMapReduce/"/>
      <url>/2019/11/21/%E6%B5%B7%E9%87%8F%E5%A4%84%E7%90%86%E4%B9%8BMapReduce/</url>
      
        <content type="html"><![CDATA[<h1 id="海量数据处理（1）：MapReduce"><a href="#海量数据处理（1）：MapReduce" class="headerlink" title="海量数据处理（1）：MapReduce"></a>海量数据处理（1）：MapReduce</h1><p>海量数据处理，就是基于海量数据的存储、删除、搜索等操作。由于数据量太大，导致要么无法在短时间内迅速处理，要么无法一次性装入内存。针对面试过程中的问题，主要有以下解决步骤</p><ul><li><p>针对时间，可以采用更加迅速的数据结构和算法，比如BloomFilter、Hash、堆、Bitmap等</p></li><li><p>针对空间，无非就是大而化小，分而治之。</p></li><li><p>算法方面：</p><ul><li>外排序算法（External Sorting）</li><li>Map Reduce</li><li>非精确算法</li><li>概率算法</li><li>哈希算法与哈希函数（Hash Function）</li></ul><p>数据结构方面：</p><ul><li>哈希表（Hash Table）</li><li>堆（Heap）</li><li>布隆过滤器（BloomFilter）</li><li>位图（Bitmap）</li></ul></li></ul><h2 id="一、MapReduce简介"><a href="#一、MapReduce简介" class="headerlink" title="一、MapReduce简介"></a>一、MapReduce简介</h2><p>给定一个有海量单词的集合，统计每个词的出现次数，最简单的就是for循环，放进map，一台机器这样做，明显是不合适的，所以我们想到了用两台机器for循环，两台服务器去处理数据，但是到了merge环节，还是一台机器啊，这也是个瓶颈。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcmp5bzZ6ajMyNzYwdTBncGYuanBn?x-oss-process=image/format,png" alt="image-20200109140334227"></p><p>合并时候也可以采用并行的方式，有两种选择</p><ul><li>一是以机器来划分（比如第i台到第j台由某台机器合并）</li><li>二是根据key来划分（比如key由a、b、c、d，让一台机器合并key a和key b）</li></ul><p>很显然以机器作为划分并不好，因为进行了第一轮合并了后，还要再进行合并…最后形成一个类似树状结构的，后面的机器得要等前面机器合并完了才能继续工作，依赖性较强。所以才用根据key来划分（没有前后依赖性，系统复杂度低），这就有了MapReduce。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcmxxdjV4ajMyOGswcjY3OXYuanBn?x-oss-process=image/format,png" alt="image-20200109140833402"></p><p>注意，上面的map中采用了合并，这实际上是不对的，如果要合并，需要hashmap，机器里开一个hashmap肯定是放不下的，map的主要任务是打乱，不做合并。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcms3bW8yajMyOHUwcHVhZm0uanBn?x-oss-process=image/format,png" alt="image-20200109141250219"></p><h2 id="二、Map函数和Reduce函数"><a href="#二、Map函数和Reduce函数" class="headerlink" title="二、Map函数和Reduce函数"></a>二、Map函数和Reduce函数</h2><p>Map函数和Reduce函数的输入输出必须是<code>key-value</code>的形式</p><ul><li>Map 输入 key：文章存储地址，value：文章内容</li><li>Reduce 输入key：Map输出的key，Value：Map输出的value</li></ul><p><a href="https://www.lintcode.com/problem/word-count-map-reduce/description" target="_blank" rel="noopener">LintCode 499.单词计数</a></p><p>实现map和reduce函数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//OutputCollector是辅助输出的工具</span><span class="token keyword">class</span> <span class="token class-name">OutputCollector</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">collect</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">WordCount</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//value是文章</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String value<span class="token punctuation">,</span> OutputCollector<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>            StringTokenizer tokenizer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tokenizer<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String outputKey <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>outputKey<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//不做merge</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Reduce</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//key和value都是map输出的,某个key出现n此就有n个1，只要把Iterator中所有的1加起来即可</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> values<span class="token punctuation">,</span> OutputCollector<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> values<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="三、传输整理"><a href="#三、传输整理" class="headerlink" title="三、传输整理"></a>三、传输整理</h2><p>在Map到Reduce的过程中有个传输整理，这个流程如图所示</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcmtrbWY2ajMyOHUwcHVhZm0uanBn?x-oss-process=image/format,png" alt="image-20200109142649235"></p><p>Partition和Sort就是传输整理，在这个过程中ab分为一组，cd分为一组，这个分组是由master的一致性hash来进行分组，由于分组存在硬盘上，采用外部排序。排序时key作为第一关键字，value作为第二关键字。接下来是Reduce的工作，通过Fetch把排好序的文件拿到自己的机器上，并对这些文件进行k路归并成Reduce的输入。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcm15anl5ajMyNGYwdTBncnguanBn?x-oss-process=image/format,png" alt="image-20200109143009331"></p><p>下面介绍两个应用</p><h2 id="四、利用MapReduce建立倒排索引"><a href="#四、利用MapReduce建立倒排索引" class="headerlink" title="四、利用MapReduce建立倒排索引"></a>四、利用MapReduce建立倒排索引</h2><p>正排：序号-&gt;关键字，倒排：给定文章关键词，返回文章序号，就比如google上搜索关键词，返回网页。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcm1kc3VxajMyOHkwZjBkaGQuanBn?x-oss-process=image/format,png" alt="image-20200109143417433"></p><p>map输出的key是文章的关键词，value是文章的编号。在reduce中需要进行去重操作</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcmt1NGxuajMyOW0wbTI3OXAuanBn?x-oss-process=image/format,png" alt="image-20200109143559740"></p><p><a href="https://www.lintcode.com/problem/inverted-index-map-reduce/description" target="_blank" rel="noopener">LintCode 504. 倒排索引</a></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//OutputCollector是辅助输出的工具</span><span class="token keyword">class</span> <span class="token class-name">OutputCollector</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">collect</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Document</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> String content<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvertedIndex</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// value是对应文章的id</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>String _<span class="token punctuation">,</span> Document value<span class="token punctuation">,</span> OutputCollector<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>            StringTokenizer tokenizer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tokenizer<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String word <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> value<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Reduce</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> values<span class="token punctuation">,</span> OutputCollector<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用于去重</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Integer now <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">!=</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                left <span class="token operator">=</span> now<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//key->包含该key的文章</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、利用MapReduce对Anagram进行分组"><a href="#五、利用MapReduce对Anagram进行分组" class="headerlink" title="五、利用MapReduce对Anagram进行分组"></a>五、利用MapReduce对Anagram进行分组</h2><p>Anagram的特性就是能够随意改变单词中字母顺序，如果把内部字母排个序，那么只要是Anagram就会变成同一个单词。经过内部排序的单词就能够作为key，而原单词就是value。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYXFpcm5yZjZvajMyOHUwbnFqd2guanBn?x-oss-process=image/format,png" alt="image-20200109145006642"></p><p><a href="https://www.lintcode.com/problem/anagram-map-reduce/description" target="_blank" rel="noopener">LintCode 503. 乱序字符串</a></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//OutputCollector是辅助输出的工具</span><span class="token keyword">class</span> <span class="token class-name">OutputCollector</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">collect</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Anagram</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String value<span class="token punctuation">,</span> OutputCollector<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>            StringTokenizer tokenizer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tokenizer<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String word <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">;</span>                output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Reduce</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> values<span class="token punctuation">,</span> OutputCollector<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> output<span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 海量数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海量数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码</title>
      <link href="/2019/09/11/LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/09/11/LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>&emsp;&emsp;底层数据结构是<strong>双向链表</strong>，如图。链表中没数据时，first和last是同一个结点，前后指向null。因为是个双向链表，只要机器内存足够大，没有大小限制。</p><p><img src="https://img-blog.csdnimg.cn/20200209214704149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OzywFitY-1581256004798)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191211153542310.png)\]"></p><p>内部有一个Node类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        E item<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//节点值</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//指向后继</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//指向前驱</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="1、-新增"><a href="#1、-新增" class="headerlink" title="1、 新增"></a>1、 新增</h4><p>&emsp;&emsp;追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法<strong>默认是从尾部开始追加</strong>，通过移动尾节点的 next 指向，addFirst 方法是从头部开始追加，通过移动头节点的 prev 指向。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//从尾部增加</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//把尾节点数据暂存</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//新建节点，l是新节点的前驱，e为要新增的节点，新增节点的后一个节点为null</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（前驱、本身、后继）</span>          <span class="token comment" spellcheck="true">//把newNode追加到尾部</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//链表空与不空两种情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//大小与版本的修改</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//从头部增加</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//头节点赋给临时变量</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//新建节点，新节点前驱为null，e是新建节点，f为后继</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（前驱、本身、后继）</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//判断链表空不空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//修改大小与版本</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="2、-删除"><a href="#2、-删除" class="headerlink" title="2、 删除"></a>2、 删除</h4><p>&emsp;&emsp;节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。贴一个从头部删除</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> E <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> E <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//拿出头节点的值作为方法的返回值</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//拿出头节点的下一个节点</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//帮助GC回收</span>        f<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        f<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>          <span class="token comment" spellcheck="true">//头节点的下一个节点成为头节点</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//如果 next 为空，表明链表为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">else</span>              <span class="token comment" spellcheck="true">//链表不为空，头节点的前一个节点指向 null</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//修改大小与版本</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="3、-查询"><a href="#3、-查询" class="headerlink" title="3、 查询"></a>3、 查询</h4><p>&emsp;&emsp;链表查询某一个节点是比较慢的，需要挨个循环查找才行。</p><pre class=" language-java"><code class="language-java">    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果 index 处于队列的前半部分，从头开始找，否则从后面开始找</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>&emsp;&emsp;LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分 法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。</p><h4 id="4、-方法对比"><a href="#4、-方法对比" class="headerlink" title="4、 方法对比"></a>4、 方法对比</h4><table><thead><tr><th>方法含义</th><th>返回异常</th><th>返回特殊值</th><th>底层实现</th></tr></thead><tbody><tr><td>新增节点</td><td>add(e)</td><td>offer(e)</td><td>底层实现相同</td></tr><tr><td>删除节点</td><td>remove(e)</td><td>poll(e)</td><td>链表为空时，remove 会抛出异常，poll 返回 null。</td></tr><tr><td>查找节点</td><td>element(e)</td><td>peek()</td><td>链表为空时，element 会抛出异常，peek 返回 null。</td></tr></tbody></table><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>   <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Deque<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</code></pre><p>&emsp;&emsp;LinkedList 也实现了 Deque 接口，对新增、删除和查找都提供从头开始，还是从尾开始两种方向的方法，比如 remove 方法，Deque 提供了 removeFirst 和 removeLast 两种方向的使用方式，但当链表为空时的表现都和 remove 方法一样，都会抛出异常。</p><h4 id="5、-迭代器"><a href="#5、-迭代器" class="headerlink" title="5、 迭代器"></a>5、 迭代器</h4><p>&emsp;&emsp;因为 LinkedList 要实现双向的迭代访问，所以我们使用 Iterator 接口肯定不行了，因为 Iterator 只支持从头到尾的访问。Java 新增了一个迭代接口，叫做ListIterator，这个接口提供了向前和向后的迭代方法。</p><table><thead><tr><th align="left">迭代顺序</th><th>方法</th></tr></thead><tbody><tr><td align="left">从头到尾迭代方法</td><td>hasNext、next、nextIndex</td></tr><tr><td align="left">从尾到头迭代方法</td><td>hasPrevious、previous、previousIndex</td></tr></tbody></table><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> lastReturned<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//上一次执行 next() 或者 previos() 方法时的节点位置</span>        <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下一个节点</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//下一个节点的位置</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//期望版本号与目标版本号</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下一个节点的索引小于链表的大小，就有</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//检查期望版本号有无发生变化</span>            <span class="token function">checkForComodificaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//再次检查</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//把上一个节点位置改为当前节点</span>            lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// next 是下一个节点了，为下次迭代做准备</span>            next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//返回节点值</span>            <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//从尾到头迭代    </span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextIndex <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 取前一个节点</span>        <span class="token keyword">public</span> E <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// next 为空场景:1:说明是第一次迭代，取尾节点(last);2:上一次操作把尾节点删除掉了</span>              <span class="token comment" spellcheck="true">// next 不为空场景:说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span>            lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 索引位置变化</span>            nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//迭代器删除</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况:</span>                        <span class="token comment" spellcheck="true">// lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错</span>              <span class="token comment" spellcheck="true">// lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//删除当前节点</span>            <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>                next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>            <span class="token keyword">else</span>                nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>            expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h4 id="6、-面试问题"><a href="#6、-面试问题" class="headerlink" title="6、 面试问题"></a>6、 面试问题</h4><p>（1）<strong>ArrayList 和 LinkedList 有何不同?</strong></p><blockquote><p>答:先从底层数据结构开始说起，然后以某一个方法为突破口深入，比如:最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p></blockquote><p>（2）<strong>ArrayList 和 LinkedList 应用场景有何不同</strong></p><blockquote><p>答:ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹 配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p></blockquote><p>（3）<strong>ArrayList 和 LinkedList 两者有没有最大容量</strong></p><blockquote><p>答:ArrayList 有最大容量的，为 Integer 的最大值，LinkedList 底层是双向链表，理论上可以无限大,但源码中，LinkedList 实际大小用 的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p></blockquote><p>（4）<strong>ArrayList 和 LinkedList 是如何对 null 值进行处理的</strong></p><blockquote><p>答:ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一个值是 null 的元素删除，LinkedList 也是允许null值的新增和删除的。</p></blockquote><p>（5）<strong>ArrayList 和 LinedList 是线程安全的么，为什么?</strong></p><blockquote><p>答:当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题 的，只有当两者是共享变量时，才会有线程安全问题。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Java集合源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java源码</title>
      <link href="/2019/09/10/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/09/10/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList就是一个数组，源码中有几个重要概念</p><blockquote><ul><li>index：表示数组下标</li><li>elementData：表示数组本身</li><li>DEFAULT_CAPACITY：表示初始数组的大小，默认是10！！！（无参构造器初始化是0，10 是在第一次 add 的时候扩容的数组值。）</li><li>size：表示当前数组的大小，没有用volatile修饰，非线程安全</li><li>modCount：统计当前数组被修改的次数，数组结构有变动，就会+1</li></ul></blockquote><p>一些重要注释</p><blockquote><ul><li>ArrayList允许put null值</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O(1)</li><li>是非线程安全的，多线程情况下，推荐使用线程安全类</li><li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li></ul></blockquote><h4 id="1、-初始化"><a href="#1、-初始化" class="headerlink" title="1、 初始化"></a>1、 初始化</h4><p>有三种初始化办法:无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 无参初始化，数组大小为空</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 指定初始数据来初始化</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// elementData是保存数组的容器，默认为null</span>        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 如果初始集合c有值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果集合元素不是Object类型，则转成Object类型</span>            <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果初始集合c没值，则默认空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>注意</strong></p><ul><li>ArrayList 无参构造器初始化时，<strong>默认大小是空数组</strong>，并不是10，10 是在第一次 add 的时候扩容的数组值。</li></ul><h4 id="2、-新增与扩容"><a href="#2、-新增与扩容" class="headerlink" title="2、 新增与扩容"></a>2、 新增与扩容</h4><p>新增就是往数组中添加元素，主要分为两步。</p><blockquote><ul><li>首先看要不要扩容，如果需要就先扩容</li><li>直接赋值</li></ul><p>新增源码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//确保数组大小是否足够，不够则直接扩容，size是当前数组的大小，+1就是增加后的大小</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>              <span class="token comment" spellcheck="true">//直接赋值，这是线程不安全的</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></blockquote><p><strong>扩容(ensureCapacityInternal)源码</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//确保容量足够</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 记录数组被修改的次数</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果我们需要的最小容量 大于 当前数组的长度，那就需要扩容了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//扩容，把现有数据拷贝到新的数组中</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//新数组容量</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//如果扩容后的容量 &lt; 期望的容量，那就让期望容量成为新容量，因为至少需要这么多的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果扩容后的容量 > jvm能分配的最大值，那么就用 Integer 的最大值，上界</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过复制进行扩容</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>扩容成原来大小的1.5倍</li><li>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</li><li>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</li></ul><p><strong>扩容本质</strong></p><blockquote><p>通过代码<code>Arrays.copyOf(elementData, newCapacity);</code>来实现扩容，就是数组的拷贝，新建一个符合预期容量的新数组，然后把老数据拷贝过去。<code>Arrays.copyOf</code>是通过<code>System.arraycopy</code>来实现的，这个方法是native方法，源码如下。</p></blockquote><h4 id="3、-删除"><a href="#3、-删除" class="headerlink" title="3、 删除"></a>3、 删除</h4><p>&emsp;&emsp;ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，这里选取根据值删除方式来进行源码说明：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//如果要删除的是null，找到第一个为null的删除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">//调用根据索引位置来删除</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//如果要删除的值不为null，找到第一个和要删除的值相等的元素删除</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">//！！注意！！这里是根据equals来判断值是否相等，然后根据索引位置来删除</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>新增元素时可以增加null元素，所以删除时也是允许删除null元素的</li><li>找到值在数组中的索引位置，通过equals来判断相不相等等。</li></ul><p>下面是fastRemove方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//记录修改次数</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//numMoved表示删除index上的元素后，有多少个元素要移动到元素前面去（数据结构知识）</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">//把index后面的元素拷贝过去</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//数组最后一个元素赋值null，帮助GC</span>                elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token punctuation">}</span></code></pre><h4 id="4、-迭代器"><a href="#4、-迭代器" class="headerlink" title="4、 迭代器"></a>4、 迭代器</h4><p>&emsp;&emsp;如果要自己实现迭代器，实现 java.util.Iterator 类就好了，ArrayList 也是这样做的，它里面的Itr实现了迭代器接口。迭代器有三个重要参数，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 迭代过程中下一个元素的位置，默认从0开始</span>    <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// add场景：表示上一次迭代过程中索引的位置，remove场景：-1</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//迭代过程中期望的版本次数。</span></code></pre><p>ArrayList迭代器的三个方法源码</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>               <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token function">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//有没有值可以迭代</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//如果下一个元素位置和大小相等，说明已经迭代完了，不等则还可以继续迭代</span>            <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//迭代过程中判断版本号有没有被修改，如果被修改了，抛出ConcurrentModificationException异常</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//下一个元素位置</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> size<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//为下一次迭代做准备</span>            cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//返回元素值</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//如果lastRet值为-1，说明数组已经被删完了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//迭代过程中判断版本号有没有被修改</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastRet<span class="token punctuation">)</span><span class="token punctuation">;</span>                cursor <span class="token operator">=</span> lastRet<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//-1表示元素已经被删除，写这一句是为了避免重复删除的操作</span>                lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//删除后modCount已经发生变化，要把它赋值给expectedModCount，下一次迭代两个值就一致了</span>                expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//补上</span>      <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span></code></pre><p>&emsp;&emsp;只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的。ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型是不可见(volatile)的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><p>&emsp;&emsp;类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低。</p><h4 id="5、-面试问题"><a href="#5、-面试问题" class="headerlink" title="5、 面试问题"></a>5、 面试问题</h4><p>（1）<strong>ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少?</strong></p><blockquote><p>答:此处数组的实际大小是 1，但下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时， 是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p></blockquote><p>（2） <strong>如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少?</strong></p><blockquote><p>答:这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但 实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是:oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity 表示数组现有大小，目前场景计算公式是:10 + 10 /2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p></blockquote><p>（3）<strong>数组初始化，被加入一个值后，如果我使用 addAll 方法，再一下子加入 15 个值，那么最终数组的大小是多少?</strong></p><blockquote><p>答:第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是:10 + 10 /2 = 15，这时候发现扩容后的大小仍 然不到我们期望的值 16，这时候源码中有一种策略如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小 </span><span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span></code></pre><p>所以最终数组扩容后的大小为 16。</p></blockquote><p>（4）<strong>现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝?</strong></p><blockquote><p>答:因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以说新建数组时，指定新数组的大小为 5k 即可。</p></blockquote><p>（5）<strong>有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for 循环的方式想把3删除，可以删除干净吗？最终结果是什么？为什么</strong></p><blockquote><p>答:不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉，原因我们看下图</p><p><img src="https://img-blog.csdnimg.cn/20200209214231739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yL9JKWWP-1581255614347)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191211164341073.png)\]"></p><p>每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p></blockquote><p>（6）<strong>还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么?</strong></p><blockquote><p>答:不可以，会报错。因为增强 for 循环调用的就是迭代器的 next () 方法，当你调用 remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时， expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。</p></blockquote><p>（7）<strong>还是上面的数组，如果删除时使用list. Iterator 然后remove () 可以删除么，为什么?</strong></p><blockquote><p>答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。</p></blockquote><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// for (int i = 0; i &lt; list.size(); i++) {</span>        <span class="token comment" spellcheck="true">//     if (list.get(i) == 3) {</span>        <span class="token comment" spellcheck="true">//         list.remove(i);</span>        <span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">// }</span>          <span class="token comment" spellcheck="true">//增强型for循环调用的是迭代器的next，list.remove然后会调用fastRemove</span>        <span class="token comment" spellcheck="true">//前面是迭代器的版本号，后面是list里面持有的版本号，list调用remove，版本号+1</span>        <span class="token comment" spellcheck="true">//但是前面迭代器的版本号是没变的。</span>        <span class="token comment" spellcheck="true">// for (Integer i : list) {</span>        <span class="token comment" spellcheck="true">//     if (i == 3) {</span>        <span class="token comment" spellcheck="true">//         list.remove(i);</span>        <span class="token comment" spellcheck="true">//     }</span>        <span class="token comment" spellcheck="true">// }</span>        Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer next <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//迭代器的remove，而不是list的</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//主要就是看这个迭代器是不是list自己的</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Java集合源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/29/JVM%E4%B9%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/08/29/JVM%E4%B9%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="G1垃圾回收器详解与回收性能优化"><a href="#G1垃圾回收器详解与回收性能优化" class="headerlink" title="G1垃圾回收器详解与回收性能优化"></a>G1垃圾回收器详解与回收性能优化</h1><h2 id="一、G1的引出"><a href="#一、G1的引出" class="headerlink" title="一、G1的引出"></a>一、G1的引出</h2><h3 id="1、G1与堆内存"><a href="#1、G1与堆内存" class="headerlink" title="1、G1与堆内存"></a>1、G1与堆内存</h3><p>&emsp;&emsp;新生代还是老年代，<code>Stop the World</code>是最大的痛点，它们都会产生这个现象，影响系统的运行，所有垃圾回收器的优化都是朝着减少STW的目标去做的，G1便应运而生了。G1可以同时回收新生代和老年代，<strong>它的最大特点，就是把Java堆内存拆分为多个大小相等的<code>Region</code></strong>，如图，所以G1的新生代老年代是一种逻辑上的概念了，新生代可能包含了某些<code>Region</code>，老年代可能包含了某些<code>Reigon</code>。<strong>另一个最大特点，就是允许我们设置一个垃圾回收的预期停顿时间，比如我们可以指定1小时内回收垃圾的时候产生的STW时间要小于1min</strong></p><p>&emsp;&emsp;<strong>G1相比之前的垃圾回收器，最大进步就是STW可控</strong></p><p><img src="https://img-blog.csdnimg.cn/20200209152107836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FEvznQE5-1581232833681)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191025205227363.png)\]"></p><p>&emsp;&emsp;给整个堆内存设置了大小后，启动JVM，一旦发现你使用的是G1垃圾回收器（通过使用<code>-XX:+UseG1GC</code>这个参数来设置），那就会自动用堆内存大小除以2048（默认情况下是这个，当然我们可以通过<code>-XX:G1HeapRegionSize</code>参数来指定），因为最多可以有2048个Region，Region的大小为2的倍数，比如堆内存给2G，那Region可能是1MB、2MB、4MB这样的，堆内存给4G，那每个Region就是2MB。</p><p>&emsp;&emsp;Region区域既有新生代，也有老年代，这时候就不需要去给他们分配内存了，这两个区域是由G1控制，不停变动的。默认新生代堆内存占比是5%，当然可以通过<code>-XX:G1NewSizePercent</code>参数来设置新生代初始占比，一般都是维持这个默认值，因为系统运行时会动态变化。</p><p>&emsp;&emsp;此外，新生代还是有Eden和Survivor划分的，之前有个参数是<code>-XX:SurvivorRatio=8</code>，意思是说80%的Eden，20%的Survivor，在这里，比如新生代初始共100个Region，那就是80个Eden，两个Survivor各占十个。随着动态分配，比如新生代的Region不断增加，那么Eden和Survivor对应的Region也会不断增加。</p><h3 id="2、G1如果做到对于系统的停顿可控的？"><a href="#2、G1如果做到对于系统的停顿可控的？" class="headerlink" title="2、G1如果做到对于系统的停顿可控的？"></a>2、G1如果做到对于系统的停顿可控的？</h3><p>&emsp;&emsp;G1要做到这一点必须<strong>追踪每一个Region的回收价值</strong>，所谓回收价值就是根据设定的预期系统停顿时间，来选择<strong>最少回收时间和最多回收对象的Region进行垃圾回收</strong>，保证GC对系统停顿的影响在可控范围内，同时还能尽可能回收最多的对象。（有点类似贪心算法）。</p><h2 id="二、G1的垃圾回收机制"><a href="#二、G1的垃圾回收机制" class="headerlink" title="二、G1的垃圾回收机制"></a>二、G1的垃圾回收机制</h2><h3 id="1、G1新生代Region的垃圾回收"><a href="#1、G1新生代Region的垃圾回收" class="headerlink" title="1、G1新生代Region的垃圾回收"></a>1、G1新生代Region的垃圾回收</h3><p>前提：新生代占据了整个堆大小的60%。（比如我们划分了2000个Region，差不多有1200个新生代Region，其中Eden占1000个，每个Survivor各占100个，如图）</p><p><img src="https://img-blog.csdnimg.cn/20200209152119896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MUkGTmiC-1581232833683)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191025220101126.png)\]"></p><p>这时候还是会触发Minor GC，使用复制算法，进入<code>Stop the World</code>，把Eden中活着的对象放进S1对应的Region，然后回收。看起来和ParNew没区别，其实是有区别的，因为我们给G1设定了停顿时间（参数<code>-XX:MaxGCPauseMills</code>,默认200ms），那么G1首先会对每个Region追踪回收的时间，再选择，来尽可能多回收掉一点对象。</p><p><strong>当然也有进入老年代的几种情况：</strong></p><ul><li><p><strong>第一种</strong>是超过我们设定的年龄阈值的对象，就会进入老年代Region；</p></li><li><p><strong>第二种</strong>是存活的对象超过了Survivor的50%（动态年龄判断规则）</p></li></ul><p><strong>对于大对象的处理，不放入老年代</strong>!!G1提供了专门的Region来存放大对象（并不是60%新生代，40%老年代，动态变化的，G1会自己处理），只要一个对象超过了一个Region大小的50%，就会被放过去，这个对象如果太大，还可以横跨多个Region来存放。另外大对象的回收是跟着新生代老年代的回收一起进行的。</p><h3 id="2、G1混合垃圾回收——Mixed-GC"><a href="#2、G1混合垃圾回收——Mixed-GC" class="headerlink" title="2、G1混合垃圾回收——Mixed GC"></a>2、G1混合垃圾回收——Mixed GC</h3><h4 id="（1）Mixed-GC的触发时机"><a href="#（1）Mixed-GC的触发时机" class="headerlink" title="（1）Mixed GC的触发时机"></a>（1）Mixed GC的触发时机</h4><p>G1有一个参数，是<code>-XX:InitiatingHeapOccupancyPercent</code>，他的默认值是45%,这个参数的意思是如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。</p><h4 id="（2）Mixed-GC的停止时机"><a href="#（2）Mixed-GC的停止时机" class="headerlink" title="（2）Mixed GC的停止时机"></a>（2）Mixed GC的停止时机</h4><p><strong>混合回收都是基于复制算法进行的</strong>，把要回收的Region区存活的对象放入其他Region，然后这个Region全部清理掉，这样就会不断空出来新的Region，有一个参数<code>-XX:G1HeapWastePercent</code>，默认值是5%，就是说空出来的区域大于整个堆的5%，就会立即停止混合回收了。正常默认回收次数是8次，但是可能到了4次，发现空闲Region大于整个堆的5%，就不会再进行后续回收了。</p><h4 id="（3）回收失败问题"><a href="#（3）回收失败问题" class="headerlink" title="（3）回收失败问题"></a>（3）回收失败问题</h4><p>可以看出<strong>G1整体都是基于复制算法进行，不会出现内存碎片问题</strong>，但另一个问题是，Mixed GC中新生代、老年代都是复制算法，对象复制时候别的Region内存不够了咋办？那就是回收失败了！就会立即停止系统程序，然后采用单线程去标记、清理、压缩整理，再空闲出新的Region，这个过程极其缓慢！（<strong>采用的是Serial Old回收器</strong>）</p><h3 id="3、Mixed-GC的四个阶段"><a href="#3、Mixed-GC的四个阶段" class="headerlink" title="3、Mixed GC的四个阶段"></a>3、Mixed GC的四个阶段</h3><h4 id="（1）初始标记阶段"><a href="#（1）初始标记阶段" class="headerlink" title="（1）初始标记阶段"></a>（1）初始标记阶段</h4><p>这个过程需要进入<code>Stop the World</code>的，仅仅只是标记一下GC  Roots直接能引用的对象，这个过程速度是很快的。如下图，<strong>先停止系统程序的运行</strong>，然后<strong>对各个线程栈内存中的局部变量代表的GC Roots，以及方法区中的类静态变量代表的GC Roots，进行扫描</strong>，标记出来他们直接引用的那些对象。</p><p><img src="https://img-blog.csdnimg.cn/20200209152138972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKehIY34-1581232833684)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191025224910516.png)\]"></p><h4 id="（2）并发标记阶段"><a href="#（2）并发标记阶段" class="headerlink" title="（2）并发标记阶段"></a>（2）并发标记阶段</h4><p>这个阶段会<strong>允许系统程序的运行</strong>，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，并对这个过程对象的变化<strong>做记录</strong>，比如哪些对象失去了引用，哪些对象是新建的。如下图所示。（这个阶段也是很耗时的，要追踪全部存活的对象，但跟系统并发运行，影响不大）</p><p><img src="https://img-blog.csdnimg.cn/20200209152155526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-k9y2CwrZ-1581232833686)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191025225048722.png)\]"></p><h4 id="（3）最终标记阶段"><a href="#（3）最终标记阶段" class="headerlink" title="（3）最终标记阶段"></a>（3）最终标记阶段</h4><p>这个阶段会进入<code>Stop the World</code>，<strong>系统程序是禁止运行的</strong>，但是会根据并发标记阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/20200209152209589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yPNSOlQI-1581232833687)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191025225515257.png)\]"></p><h4 id="（4）混合回收阶段"><a href="#（4）混合回收阶段" class="headerlink" title="（4）混合回收阶段"></a>（4）混合回收阶段</h4><p>&emsp;&emsp;基于复制算法，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。<strong>接着会停止系统程序</strong>，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我们指定的范围内。</p><p>&emsp;&emsp;注意，这里到底回收哪些Region是G1自己选择的，<strong>这里的混合回收是指在我们指定的时间（比如200ms）内回收尽可能多的垃圾。</strong></p><p>&emsp;&emsp;<strong>另外，这个阶段G1允许多次执行混合回收</strong>，也就是说先停止系统工作，执行回收，恢复系统运行，再停止系统运行，再回收，再恢复…这么一个流程。每次回收的间隔是由G1自己控制的，回收执行次数可以通过参数<code>-XX:G1MixedGCCountTarget</code>来设置，这个参数默认回收次数是8次，同时有一个参数<code>-XX:G1HeapWastePercent</code>，默认值是5%，就是说空出来的区域大于整个堆的5%，就会立即停止混合回收了。正常默认回收次数是8次，但是可能到了4次，发现空闲Region大于整个堆的5%，就不会再进行后续回收了。这种多次回收的机制能够让系统停顿时间不要太长，可以在多次回收的间隙也运行一下。</p><p><img src="https://img-blog.csdnimg.cn/20200209152245697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cCauDw0d-1581232833688)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191025225705796.png)\]"></p><h3 id="4、G1垃圾回收的参数"><a href="#4、G1垃圾回收的参数" class="headerlink" title="4、G1垃圾回收的参数"></a>4、G1垃圾回收的参数</h3><ul><li><code>-XX:+UseG1GC</code>：设置使用G1垃圾回收器</li><li><code>-XX:MaxGCPauseMills</code>：设定系统停顿时间，默认200ms</li><li><code>-XX:G1HeapRegionSize</code>：设置区域划分的个数和大小，默认<code>堆大小/2048</code></li><li><code>-XX:G1NewSizePercent</code>：用来设置新生代初始占比的，默认值为5%即可。</li><li><code>-XX:G1MaxNewSizePercent</code>：用来设置新生代最大占比的，默认值为60%即可。</li><li><code>-XX:SurvivorRatio=8</code>：设置新生代Region区域中Eden和Survivor的比例，默认8:1:1</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置Mixed GC的比例，默认45%</li><li><code>-XX:G1MixedGCCountTarget</code>：混合回收阶段最多允许G1执行回收的次数，默认是8次。</li><li><code>-XX:G1HeapWastePercent</code>：默认值5%，Mixed GC时空出来的Region大于5%，就停止混合回收。</li><li><code>-XX:G1MixedGCLiveThresholdPercent</code>：默认值是85%，确定要回收的Region的时候，必须是存活对象低于85%的Region才可以回收。</li></ul><h2 id="三、G1性能优化"><a href="#三、G1性能优化" class="headerlink" title="三、G1性能优化"></a>三、G1性能优化</h2><h3 id="1、背景引入"><a href="#1、背景引入" class="headerlink" title="1、背景引入"></a>1、背景引入</h3><p>&emsp;&emsp;百万级用户的在校教育平台，首先分析这个系统最高频的行为。作为用户，浏览课程详情、下单付费、选课排课，这些都是绝对的低频行为，我们几乎不用考虑到系统的运行中去，可以暂时忽略掉。对于这样的一个系统，他最关键的高频行为只有<strong>上课！</strong>就是每天晚上那两三小时的高峰时期，几乎你可以认为每天几十万日活用户（那些小孩儿）都会集中在这个时间段来平台上上在线课程。所以这个晚上两三小时的时间段里，将会是平台每天绝对的高峰期。那哪个功能最常用呢？除了上课学习，就是<strong>互动</strong>了。</p><p>&emsp;&emsp;分析这个系统核心点就是搞明白在晚上两三小时高峰期内，<strong>每秒钟会有多少请求，每个请求会连带产生多少对象，占用多少内存，每个请求要处理多长时间。</strong></p><p>&emsp;&emsp;假设晚上3小时有60w活跃用户，按平均每个用户1小时上课，每小时20w用户，对于每个用户1分钟1次互动，1分钟60次，20万人1分钟就是1200万次互动，平均每秒3000次，也就是1秒承受3000次请求。假设我们使用的是4核8G的机器，差不多需要5台，每台1秒抗住600个请求。互动过程一般不会有复杂对象，算上连带对象也就占几KB，假设5KB，1秒就是3MB左右内存（5*600/1000）。</p><p>&emsp;&emsp;分配4G给堆内存，其中新生代默认初始占比为5%，最大占比为60%，每个Java线程的栈内存为1MB，元数据区域（永久代）的内存为256M，新生代初始占比和最大新生代占比维持默认值即可，不用设置，分别为5%和60%，此时JVM参数如下：</p><pre><code>-Xms4096M -Xmx4096M  -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseG1GC</code></pre><p>&emsp;&emsp;此时每个Region大小为4G/2048 = 2MB，新生代占5%，算它100个Region，200MB，停顿时间我们先不设置，使用默认值200ms。此时大概不到1分钟就塞满这100个新生代Region了，此时你会觉得由于GC是很灵活的，他会根据你设定的gc停顿时间给你的新生代不停分配更多Region，然后到一定程度，感觉差不多了，就会触发新生代gc，保证新生代gc的时候导致的系统停顿时间在你预设范围内，这是它的一个原理，但事实不是这样的，具体情况要通过工具去查看。</p><h3 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h3><p><strong>对于新生代，主要是避免短生命对象进入老年代</strong></p><ul><li>预估每次Minor GC后存活下来对象的大小，合理的设置Survivor区，同时考虑高峰期间时，动态年龄判断条件的影响，不要让这种短生命周期对象侥幸逃脱进入老年代</li><li>大对象有他自己的Region，不用操心</li></ul><p><strong>对于老年代</strong></p><ul><li>系统的停顿时间时关键！是核心，要预测停顿时间，并不是越小越好，过小则回收效果不大</li></ul><p>（1）-XX:MaxGCPauseMills 参数优化</p><p>这个参数是核心点！如果参数设置的值很大，导致系统运行很久，新生代可能都占用了堆内存的60%了，此时才触发新生代GC，那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象（或是动态年龄判定规则），就会进入老年代中。如果参数设置过小，即使GC停顿时间很短，但GC频率太大，比如说30秒触发一次新生代gc，每次就停顿30毫秒，这样也是很影响系统性能的。至于到底如何优化这个参数，<strong>要结合工具的实战演练</strong>。</p><p>（2）Mixed GC优化</p><p>优化Mixed GC并不是优化它的参数，因为它的参数太多了，尽量避免对象过快进入老年代，尽量避免频繁触发Mixed GC，就可以做到根本上优化Mixed GC了。这边核心还是<code>-XX:MaxGCPauseMills</code>这个参数。如上所说</p><h2 id="四、G1的适用场景与总结"><a href="#四、G1的适用场景与总结" class="headerlink" title="四、G1的适用场景与总结"></a>四、G1的适用场景与总结</h2><h3 id="1、适合超大内存机器"><a href="#1、适合超大内存机器" class="headerlink" title="1、适合超大内存机器"></a>1、适合超大内存机器</h3><p>&emsp;&emsp;如果内存是一个<strong>大堆</strong>，比如部署在有16G、32G的内存的机器上，比如类似Kafka、Elasticsearch之类的大数据相关的系统，都是部署在大内存的机器上的，此时如果你的系统负载非常的高，比如每秒几万的访问请求到Kafka、Elasticsearch上去。那么可能导致你Eden区的几十G内存频繁塞满要触发垃圾回收，假设1分钟会塞满一次。如果使用传统回收器（比如ParNew+CMS），不用G1，会导致新生代每次GC回收的次数太多了，STW一多，停顿时间太长，使用G1可以指定每次停顿的时间来回收一部分Region，这样就很合适。从上面停顿时间太长这个角度出发，G1就适合要求<strong>低延时</strong>的业务。</p><p>&emsp;&emsp;另外G1压缩内存空间有优势，适合会产生大量碎片的应用。</p><p><strong>ParNew+CMS适合内存小的</strong></p><h3 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h3><h4 id="（1）G1小结"><a href="#（1）G1小结" class="headerlink" title="（1）G1小结"></a>（1）G1小结</h4><p>G1和ParNew+CMS的调优原则都是尽可能Minor GC，G1则更加智能，而PN+CMS更纯粹更直接，虽然G1在GC时没有碎片，但是由于每个Region有一个存活率大于85%不清理的机制，会导致内存没有充分释放。因此，对于cpu性能高的，内存容量大的，对应用响应度高的系统推荐使用g1。 而内存小，cpu性能比较低下的系统也可以使用pn+cms会更合适。</p><h4 id="（2）回收过程小结"><a href="#（2）回收过程小结" class="headerlink" title="（2）回收过程小结"></a>（2）回收过程小结</h4><ol><li>如果新生代未达60%，老年代未达45%，系统照常运行，不会触发回收 </li><li>如果新生代达60%，此时如果有新对象生成，跑到新生代，就会触发Minor GC<ol><li>开启了空间担保机制，Minor GC前先判断是否需要Full GC,如果每次回收后对象小于老年代空闲大小，则不用Full,否则要。（JDK 1.6之前是把空间担保机制和<code>HandlerPromotionFailure</code>参数拆开了，JDK 1.6之后的空间担保机制只要满足”老年代可用连续空间&gt;新生代对象总大小或历次晋升到老年代对象的平均大小”其中一个就可，不满足就Full GC）</li><li>不用触发Full GC，但Minor GC后的对象大于老年代空闲大小，无法直接进入老年代，触发Full GC</li><li>老年代堆内存占了45%了，触发混合回收（四个阶段：先STW通过GC Root初始标记哪些是有直接引用的，然后并发标记追踪GC Roots所有对象，此时与系统并发执行，接着最终标记，STW，标记并发标记过程中心新来的对象和新产生的垃圾，最后混合回收，采用的是复制算法，不会产生垃圾碎片，G1按照我们给定时间去进行性价比高的回收，回收次数可以设置，默认是八次，如果回收过程中，空闲Region超过了堆内存的5%，会提前结束，当然可以修改这个参数，另外如果回收失败，转而使用Serial Old回收器，回收变得很慢）</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/27/JVM%E4%B9%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3JVM%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
      <url>/2019/08/27/JVM%E4%B9%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3JVM%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="三、新生代JVM参数优化"><a href="#三、新生代JVM参数优化" class="headerlink" title="三、新生代JVM参数优化"></a>三、新生代JVM参数优化</h2><h3 id="1、背景引入"><a href="#1、背景引入" class="headerlink" title="1、背景引入"></a>1、背景引入</h3><p>&emsp;&emsp;假设我们的背景是每日上亿请求量的一个订单系统，按照每个用户每日访问次数为20次来算，大致有500万个用户（1亿/20），对这五百万个用户，假设付费转化率为10%，也就是有50万人会去下单，我们把这50万订单集中在4个小时的高峰期内，平均每秒钟也就几十个订单，感觉也没什么大的压力，因为几十个订单根本不需要对JVM做太多关注。</p><p>&emsp;&emsp;但是如果到了双十一这种活动，就会出问题了。硬件方面来说，如果我们部署到足够的机器上以及机器内存充裕，也不是问题，但就JVM的参数来说，如果我们不能合理的去设置这个参数，就会导致机器资源浪费，硬件成本的增加。</p><p>&emsp;&emsp;为什么要去调JVM参数？我们的<strong>目的就是对JVM有限的内存资源做好合理分配和优化，当然包括垃圾回收的优化，要让GC次数尽可能的少。</strong></p><p>&emsp;&emsp;假设双十一期间一台机器1秒要处理300个订单（处理订单比较耗时，工作经验上是每秒处理100～300个订单），对于每个订单对象我们按1KB来算，那1秒就是300KB内存开销了，但是这时订单连带对象如库存、促销、优惠券等一系列业务对象，这些对象从经验上来讲好要比订单单个对象的开销再放大10倍，同时还有很多与订单相关操作，比如查询等，往大估算就再扩大十倍，<strong>所以1秒钟，我们要处理60MB（300KB x 20 x 10 = 60000KB）对象。</strong>每1秒过后，这个对象就变成垃圾了。</p><p>&emsp;&emsp;假设我们使用4核8G的机器，JVM分配4G，其中3G给堆内存，1G给方法区和每个线程的虚拟机栈。虚拟机栈一般都是1MB，假设我们有几百个线程，就是几百MB，这里我们给永久代256MB，给虚拟机栈总共768MB。至于堆内存，我们给新生代1.5G，老年代1.5G。得到如下参数。（注意这里不写<code>-XX:HandlePromotionFailure</code>，我们使用JDK 1.8）。每1秒有60MB的垃圾，1.5G的内存大概25秒就满了。此时就要<code>Minor GC</code>，明显老年代能够存放新生代所有对象，可以放心GC，由于最后一秒订单还在处理，假设存活的对象就100MB，这里来问题了，如果<code>-XX:SurvivorRatio</code>参数默认值为8，那么此时新生代里Eden区大概占据了1.2GB内存，每个<code>Survivor</code>区是150MB的内存，如下图。</p><pre><code>-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M</code></pre><p><img src="https://img-blog.csdnimg.cn/20200209151328587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;所以启动JVM后，大概20秒左右，<code>Eden</code>区就满了，然后<code>Minor GC</code>，把存活对象放在<code>Survivor1</code>中，再过20s，再次回收<code>Eden</code>和<code>Survivor1</code>中的对象，存活的如果还是100MB就放入<code>Survivor2</code>中。</p><p>&emsp;&emsp;以上就是总体的背景，此时的JVM参数为：</p><pre><code>-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8</code></pre><h3 id="2、参数优化"><a href="#2、参数优化" class="headerlink" title="2、参数优化"></a>2、参数优化</h3><h4 id="（1）Survivor空间的设置"><a href="#（1）Survivor空间的设置" class="headerlink" title="（1）Survivor空间的设置"></a>（1）Survivor空间的设置</h4><p>&emsp;&emsp;JVM优化时，首先就得考虑<code>Survivor</code>空间够不够。就上述案例，一种情况是，<code>Survivor</code>中分配了150MB，如果来的对象大于150MB，就会频繁进入老年代，第二种情况是，即使100MB对象能够放入<code>Survivor</code>区，但是100/150 = 0.67，超过了<code>Survivor</code>区空间的50%，这样同一批年龄对象也进入老年代了，这种1秒就变成垃圾的短生命周期对象根本不需要进入老年代。我们得让它们留在新生代里。</p><p>&emsp;&emsp;<strong>方案：</strong>给<code>Survivor</code>区更大的容量。如果你的<strong>业务都是这种短生命周期的</strong>，老年代可以分配少一点的内存，我们可以考虑把新生代调整为2G，老年代为1G，如果<code>-XX:SurvivorRatio=8</code>那么此时<code>Eden</code>为1.6G，每个<code>Survivor</code>为200MB，如图。这时候上述两个问题就同时解决了。</p><p>&emsp;&emsp;针对任何系统，我们要预估内存并合理分配内存，首要做的就是<strong>尽量让每次Minor GC后的对象都留在Survivor里，不要进入老年代。</strong>此时参数如下</p><pre><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8</code></pre><p><img src="https://img-blog.csdnimg.cn/20200209151417197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8wmVjoYi-1581232363623)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191024201720899.png)\]"></p><h4 id="（2）-XX-MaxTenuringThreshold参数的设置"><a href="#（2）-XX-MaxTenuringThreshold参数的设置" class="headerlink" title="（2）-XX:MaxTenuringThreshold参数的设置"></a>（2）-XX:MaxTenuringThreshold参数的设置</h4><p>&emsp;&emsp;有些对象是可能躲过15次垃圾回收进入老年代的，就上述背景，有些对象在新生代躲了几分钟进入老年代很应该，那为了不让这种数据进入老年代要怎么做？我们需要调<code>-XX:MaxTenuringThreshold</code>这个参数。这个参数并不是一昧地去调高，一定要<strong>结合系统的运行模型，看看Minor GC频率</strong>，把这个参数从15调高到20、30，让一个垃圾多在<code>Survivor</code>中停留几分钟，根本没用，对于我们上述业务场景就要把这个参数调低，比如调到5.记住，一定要结合系统运行的模型。此时参数如下：</p><pre><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5</code></pre><h3 id="（3）-XX-PretenureSizeThreshold参数设置"><a href="#（3）-XX-PretenureSizeThreshold参数设置" class="headerlink" title="（3）-XX:PretenureSizeThreshold参数设置"></a>（3）-XX:PretenureSizeThreshold参数设置</h3><p>&emsp;&emsp;大对象是可以直接进入老年代的，但是多大呢？一般来说很少有超过1MB的对象，如果有，那就是你提前分配了一个大数组、大List之类的来存放缓存数据，一般这种数据是要用一段时间的，所以我们可以放到老年代。我们一般把这个参数设置为1。此时JVM参数如下：</p><pre><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M</code></pre><h4 id="（4）指定垃圾回收器"><a href="#（4）指定垃圾回收器" class="headerlink" title="（4）指定垃圾回收器"></a>（4）指定垃圾回收器</h4><p>&emsp;&emsp;针对具体的客户端、服务端来设置垃圾回收器，之前讲过。我们这个系统新生代使用<code>ParNew</code>，老年代使用<code>CMS</code>。设置如下的参数：</p><pre><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code></pre><h2 id="四、老年代JVM参数优化"><a href="#四、老年代JVM参数优化" class="headerlink" title="四、老年代JVM参数优化"></a>四、老年代JVM参数优化</h2><p>&emsp;&emsp;老年代参数优化主要就是减少Full GC的次数。首先我们得要分析对象进入老年代的几个原因</p><h3 id="1、对象进入老年代的原因"><a href="#1、对象进入老年代的原因" class="headerlink" title="1、对象进入老年代的原因"></a>1、对象进入老年代的原因</h3><p><strong>第一种</strong>：就是<code>-XX:MaxTenuringThreshold</code>这个参数设置的太低了，就是之前新生代的案例，这种对象一般是<code>@Service</code>或<code>Controller</code>等注解标识的业务逻辑组件，这种对象一般全局有一个实例就行，是要一直用的，所以应该让他进。</p><p><strong>第二种</strong>：就是大对象，但是这种再上述案例中一般没有，可以忽略。</p><p><strong>第三种</strong>：就是Minor GC后存活的对象超过了<code>Survivor</code>区的50%，就直接进入了老年代</p><h3 id="2、大促销场景的Full-GC多久出发一次？"><a href="#2、大促销场景的Full-GC多久出发一次？" class="headerlink" title="2、大促销场景的Full GC多久出发一次？"></a>2、大促销场景的Full GC多久出发一次？</h3><p>&emsp;&emsp;对于此案例触发Full GC的几个情况：</p><p><strong>情况一</strong>：没有打开<code>-XX:HandlePromotionFailure</code>选项。<strong>我们知道如果老年代剩余内存大于新生代对象总大小就直接Minor GC的，但是老年代剩余内存总大小小于新生代对象总大小时，就要看这个参数了，如果没有打开这个参数，老年代空间小于新生代所有对象大小就直接Full GC，如果打开了，就看平均。</strong>这个参数就是看老年代剩余内存总大小是否大于之前每一次Minor GC进入老年代的对象的平均大小，按照之前项目案例，要很多次Minor GC之后才可能有一两次碰巧会有200MB对象升入老年代，所以这个“历次Minor GC后升入老年代的平均对象大小”，基本是很小的。（JDK 1.6之后就不看了）</p><p><strong>情况二</strong>：某次升入老年代的对象很大，但是老年代空间不够了。</p><p><strong>情况三</strong>：和<code>-XX:CMSInitiatingOccupancyFaction</code>参数有关，默认值是92%，超过这个值就会GC。</p><p>&emsp;&emsp;针对大促销场景，由于我们之前在新生代优化了参数，所以对象进入老年代较慢，经验上来说，很可能是在系统运行半小时~1小时之后，才会有接近1GB的对象进入老年代。在大促期间，订单系统运行1小时之后，大促下单高峰期几乎都快过了，此时才可能会触发一次Full GC。这个高峰期过后，基本订单系统访问压力就很小了，那么GC的问题几乎就更不算什么了。</p><p>&emsp;&emsp;当然老年代也会触发<code>Concurrent Mode Failure</code>问题。假设系统，运行1小时之后，老年代大概有900MB的对象了，剩余可用空间仅仅只有100MB了，然后CMS进行垃圾回收，垃圾回收期间是和系统程序并发的，如果系统此时还在创建对象，比如说很不巧有200MB对象要进来了，而老年代又放不下，那么此时就会进入<code>Stop the World</code>，然后切换CMS为Serial Old，直接禁止程序运行，然后单线程进行老年代垃圾回收，回收掉900MB对象过后，再让系统继续运行。当然这个概率非常的小，我们没必要特意去优化它。</p><p>此时参数为:</p><pre><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=9</code></pre><h3 id="3、CMS后内存碎片整理频率"><a href="#3、CMS后内存碎片整理频率" class="headerlink" title="3、CMS后内存碎片整理频率"></a>3、CMS后内存碎片整理频率</h3><p>&emsp;&emsp;没必要特意去修改这个频率，对于上述大促销场景，在大促高峰期，Full GC可能也就1小时执行一次，然后大促高峰期过去之后，就没那么多的订单了，此时可能几个小时才会有一次Full GC。所以就保持默认的设置，每次Full GC之后都执行一次内存碎片整理就可以。要针对特定的业务场景来设定。<strong>仅仅针对这个参数来说：</strong></p><ul><li>如果Full GC相对频繁，就设置多次Full GC后进行碎片整理</li><li>如果不是很频繁，可以设置每次Full GC后进行碎片整理</li></ul><h2 id="五、面试题"><a href="#五、面试题" class="headerlink" title="五、面试题"></a>五、面试题</h2><h3 id="1、一个面试题：parnew-cms的gc，如何保证只做ygc，jvm参数如何配置？"><a href="#1、一个面试题：parnew-cms的gc，如何保证只做ygc，jvm参数如何配置？" class="headerlink" title="1、一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？"></a>1、一个面试题：parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？</h3><p>首先和垃圾收集器没什么关系，不同的垃圾收集器，只是它们的性能、吞吐量不同，并不影响垃圾回收的时机。只要在新生代根据对象的存活特征，合理的去分配Eden区和s1、s2区域的大小，尽量让垃圾在新生代被回收就好了，注意这边开启内存担保（jdk 1.6），如果eden区超过了老年代大小，不开担保的话每次MGC前都要FGC的。</p><h3 id="2、为什么老年代回收比新生代慢？"><a href="#2、为什么老年代回收比新生代慢？" class="headerlink" title="2、为什么老年代回收比新生代慢？"></a>2、为什么老年代回收比新生代慢？</h3><p>新生代存活对象小，并且采用复制算法，速度很快，复制过去直接就删除，而老年代对象量较大，遍历标记、遍历清除，然后还要整理好腾出空间来，很耗时，耗时的就是步骤二和步骤四。初始标记是从GC Roots查找直接引用的对象，并发标记也是从GC Roots出发，通过每个对象的引用地址来看哪些对象活着的，活着的又很多，就很耗时。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/25/JVM%E4%B9%8BCMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/25/JVM%E4%B9%8BCMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="老年代回收容器——CMS"><a href="#老年代回收容器——CMS" class="headerlink" title="老年代回收容器——CMS"></a>老年代回收容器——CMS</h1><h3 id="1、CMS工作原理"><a href="#1、CMS工作原理" class="headerlink" title="1、CMS工作原理"></a>1、CMS工作原理</h3><p>&emsp;&emsp;一般老年代我们选择的垃圾回收器是CMS，他采用的是<strong>标记清理算法</strong>（不是标记整理）。之前提到过<code>Stop the World</code>状态，就是垃圾回收时停止一切线程的工作，如果在这个状态下再去慢慢执行标记清理算法，会导致系统卡死时间过长，所以CMS垃圾回收器采取的是<strong>垃圾回收线程和系统工作线程尽量同时执行的模式</strong>来处理的。</p><p>&emsp;&emsp;<strong>工作原理</strong>：为了避免长时间<code>Stop the World</code>，CMS采用了4个阶段来垃圾回收，分别是初始标记、并发标记、重新标记和并发清理。其中初始标记和重新标记，耗时很短，虽然会导致<code>Stop the World</code>，但是影响不大，然后并发标记和并发清理，两个阶段耗时最长，但是是可以跟系统的工作线程并发运行的，所以对系统没太大影响。</p><h3 id="2、CMS垃圾回收的四个阶段"><a href="#2、CMS垃圾回收的四个阶段" class="headerlink" title="2、CMS垃圾回收的四个阶段"></a>2、CMS垃圾回收的四个阶段</h3><h4 id="（1）初始标记——标记直接GC-Roots（直接）"><a href="#（1）初始标记——标记直接GC-Roots（直接）" class="headerlink" title="（1）初始标记——标记直接GC Roots（直接）"></a>（1）初始标记——标记直接GC Roots（直接）</h4><p>&emsp;&emsp;在这个阶段让系统的工作线程全部停止，进入<code>Stop the World</code>状态。同时<strong>标记所有GC Roots直接引用的对象</strong>，是直接引用！比如下面这段代码，仅仅会通过<code>replicaManager</code>这个类的静态变量代表的GC Roots，去标记出来他直接引用的<code>ReplicaManager</code>对象，不会去管<code>ReplicaFetcher</code>这种对象，因为<code>ReplicaFetcher</code>对象是被<code>ReplicaManager</code>类的<code>replicaFetcher</code>实例变量引用的。（之前说过，方法的局部变量和类的静态变量是GC Roots。但是类的实例变量不是GC Roots。）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReplicaManager</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ReplicaFetcher replicaFetcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaFetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200208172012902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fk34GSB4-1581153515938)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023210028357.png)\]"></p><p>初识标记如图所示</p><h4 id="（2）并发标记——对老年代所有对象进行GC-Roots追踪（最耗时）"><a href="#（2）并发标记——对老年代所有对象进行GC-Roots追踪（最耗时）" class="headerlink" title="（2）并发标记——对老年代所有对象进行GC Roots追踪（最耗时）"></a>（2）并发标记——对老年代所有对象进行GC Roots追踪（最耗时）</h4><p>&emsp;&emsp;这个阶段会让系统线程可以随意创建各种新对象，继续运行。在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行GC Roots追踪。GC Roots追踪，意思就是对类似<code>ReplicaFetcher</code>之类的全部老年代里的对象，他会去看他被谁引用了，<strong>认定为是被GC Roots间接引用后，就不需要回收它。因为老年代里存活对象是比较多的，这个过程会追踪大量的对象，所以耗时较高。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200208172036481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4a1EWItV-1581153515940)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023210352901.png)\]"></p><h4 id="（3）重新标记"><a href="#（3）重新标记" class="headerlink" title="（3）重新标记"></a>（3）重新标记</h4><p>&emsp;&emsp;第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾，所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的。在这个阶段，要再次进入<code>Stop the World</code>阶段，重新标记下在第二阶段里新创建的一些对象，还有一些已有对象可能失去引用变成垃圾的情况。重新标记的阶段只是对变动过的<strong>少数对象</strong>进行标记，是速度很快的</p><h4 id="（4）并发清理"><a href="#（4）并发清理" class="headerlink" title="（4）并发清理"></a>（4）并发清理</h4><p>&emsp;&emsp;这个阶段就是让系统程序随意运行，然后清理掉之前标记为垃圾的对象即可，也是很耗时的。</p><p><img src="https://img-blog.csdnimg.cn/20200208172107745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cfWztAVu-1581153515941)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023210811272.png)\]"></p><h3 id="3、CMS性能分析"><a href="#3、CMS性能分析" class="headerlink" title="3、CMS性能分析"></a>3、CMS性能分析</h3><h4 id="（1）好的方面"><a href="#（1）好的方面" class="headerlink" title="（1）好的方面"></a>（1）好的方面</h4><p>&emsp;&emsp;CMS的第二阶段和第四阶段，都是很耗时的，但都和系统程序是并发执行的，所以基本这两个最耗时的阶段对性能影响不大。只有第一个阶段和第三个阶段是需要<code>Stop the World</code>的，但是这两个阶段都是简单的标记而已，速度非常的快，所以基本上对系统运行响应也不大。</p><h4 id="（2）坏的方面"><a href="#（2）坏的方面" class="headerlink" title="（2）坏的方面"></a>（2）坏的方面</h4><h5 id="①并发回收导致CPU资源紧张。"><a href="#①并发回收导致CPU资源紧张。" class="headerlink" title="①并发回收导致CPU资源紧张。"></a>①并发回收导致CPU资源紧张。</h5><p>&emsp;&emsp;并发标记和并发清理两个最耗时的阶段，使垃圾回收线程和系统工作线程同时工作，导致有限的CPU资源被垃圾回收线程占用了一部分。在这两个阶段，CMS的垃圾回收线程是比较耗费CPU资源的。CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4，比如的2核4G机器，就会占用(2+3)/4 = 1个CPU被用来垃圾回收。</p><h5 id="②Concurrent-Mode-Failure问题"><a href="#②Concurrent-Mode-Failure问题" class="headerlink" title="②Concurrent Mode Failure问题"></a>②Concurrent Mode Failure问题</h5><p>&emsp;&emsp;在并发清理阶段，CMS只不过是回收之前标记好的垃圾对象，但这个时候系统一直在运行，先把某些对象分配在新生代，然后可能触发了一次Minor GC，一些对象进入了老年代，在短时间内又没人使用这些对象，这种垃圾对象就是<strong>浮动垃圾</strong>，虽然它是垃圾，但是不会回收他们，要等到下一次才能回收。</p><p>&emsp;&emsp;<strong>CMS垃圾触发的时机是当老年代内存占用到达一定比例时，就会自动GC</strong>，<code>-XX:CMSInitiatingOccupancyFaction</code>这个参数可以设置老年代内存占用到多少比例时触发垃圾回收。JDK 1.6默认是92%。预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。如果垃圾回收期间，要放入的对象大于可用内存空间，就会发生<code>Concurrent Mode Failure</code>，即并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。此时就会自动用<code>Serial Old</code>垃圾回收器替代CMS，就是直接强行把系统程序<code>Stop the World</code>，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生。</p><h5 id="③内存碎片问题"><a href="#③内存碎片问题" class="headerlink" title="③内存碎片问题"></a>③内存碎片问题</h5><p>&emsp;&emsp;老年代的CMS采用<code>标记清理</code>算法（不是<code>标记整理</code>），每次都是标记出来垃圾对象，然后一次性回收掉，这样会导致大量的内存碎片产生，太多的内存碎片实际上会导致更加频繁的Full GC。</p><p>&emsp;&emsp;CMS有一个参数是<code>-XX:+UseCMSCompactAtFullCollection</code>，默认是打开的，意思是在Full GC之后要再次进行<code>Stop the World</code>，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。</p><p>&emsp;&emsp;还有一个参数是<code>-XX:CMSFullGCsBeforeCompaction</code>，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次Full GC之后都会进行一次内存整理，存活对象都放在一起，然后空出来大片连续内存空间可供使用。</p><p><img src="https://img-blog.csdnimg.cn/20200208172233416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LFVPZWhV-1581153515942)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023214004334.png)\]"><br>红圈处即浮动垃圾</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/24/JVM%E4%B9%8BParNew%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/24/JVM%E4%B9%8BParNew%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="新生代回收器——ParNew"><a href="#新生代回收器——ParNew" class="headerlink" title="新生代回收器——ParNew"></a>新生代回收器——ParNew</h2><h3 id="1、工作原理"><a href="#1、工作原理" class="headerlink" title="1、工作原理"></a>1、工作原理</h3><p>&emsp;&emsp;ParNew垃圾回收器如果一旦在合适的时机执行Minor GC的时候，就会把系统程序的工作线程全部停掉，禁止程序继续运行创建新的对象，然后自己就用多个垃圾回收线程去进行垃圾回收，回收的机制和算法就跟之前说的是一样的。我们启动系统的时候可以指定垃圾回收器，使用<code>-XX:+UseParNewGC</code>选项，只要加入这个选项，JVM启动之后对新生代进行垃圾回收的，就是ParNew垃圾回收器了。</p><p>&emsp;&emsp;<strong>不管是老年代回收还是新生代回收，都要<code>Stop the World</code>，因为必须让程序停止创建新对象，才能回收垃圾对象，新生代只需要一次<code>stop the world</code>的时间，在此期间完成标记清除并把存活对象转到survivor或老年代。</strong></p><hr><h3 id="2、ParNew垃圾回收器默认情况下的线程数量"><a href="#2、ParNew垃圾回收器默认情况下的线程数量" class="headerlink" title="2、ParNew垃圾回收器默认情况下的线程数量"></a>2、ParNew垃圾回收器默认情况下的线程数量</h3><p>&emsp;&emsp;产生跟CPU核数一样的线程数量，比如我们线上机器假设用的是4核CPU，或者8核CPU，或者16核CPU，那么此时ParNew的垃圾回收线程数就会分别是4个线程、8个线程、16个线程，这个东西一般不用我们手动去调节。</p><hr><h3 id="3、到底是用单线程垃圾还是多线程垃圾回收好？到底是用Serial垃圾回收器还是用ParNew垃圾回收器好？"><a href="#3、到底是用单线程垃圾还是多线程垃圾回收好？到底是用Serial垃圾回收器还是用ParNew垃圾回收器好？" class="headerlink" title="3、到底是用单线程垃圾还是多线程垃圾回收好？到底是用Serial垃圾回收器还是用ParNew垃圾回收器好？"></a>3、到底是用单线程垃圾还是多线程垃圾回收好？到底是用Serial垃圾回收器还是用ParNew垃圾回收器好？</h3><p>&emsp;&emsp;启动系统的时候是可以区分<strong>服务器模式</strong>和<strong>客户端模式</strong>的，如果你启动系统的时候加入<code>-server</code>就是服务器模式，如果加入<code>-cilent</code>就是客户端模式。他们俩的区别就是，如果你的系统部署在比如4核8G的Linux服务器上，那么就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，那么就应该是客户端模式</p><p>&emsp;&emsp;<strong>服务器模式</strong>通常运行我们的网站系统、电商系统、业务系统、APP后台系统之类的大型系统，一般都是<strong>多核CPU</strong>，所以此时如果要垃圾回收，那么肯定是用ParNew更好，因为多线程并行垃圾回收，充分利用多核CPU资源，可以提升性能。</p><p>&emsp;&emsp;如果你的Java程序是一个<strong>客户端程序</strong>，比如类似百度云网盘的Windows客户端，或者是印象笔记的Windows客户端，运行在Windows个人操作系统上呢？这种操作系统很多都是<strong>单核CPU</strong>，此时你如果要是还是用ParNew来进行垃圾回收，就会导致一个CPU运行多个线程，反而加重了性能开销，因为单CPU运行多线程会导致频繁的线上上下文切换，有效率开销，可能最后效率还不如单线程好。所以如果是类似于那种运行在Windows上的客户端程序，建议采用Serial垃圾回收器。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/24/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/24/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM学习笔记（3）：垃圾回收机制详解"><a href="#JVM学习笔记（3）：垃圾回收机制详解" class="headerlink" title="JVM学习笔记（3）：垃圾回收机制详解"></a>JVM学习笔记（3）：垃圾回收机制详解</h1><h2 id="一、GC-Roots的类型"><a href="#一、GC-Roots的类型" class="headerlink" title="一、GC Roots的类型"></a>一、GC Roots的类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM使用了<code>可达性分析算法</code>，该算法会分析每个对象，看有谁在引用他，一层层判断有没有一个<code>GC Roots</code>，在JVM规范中，<strong>局部变量</strong>是可以作为<code>GC Roots</code>的，只要一个类的对象被局部变量引用了，那就说明有一个<code>GC Roots</code>，就不能被回收了。当然，<strong>静态变量</strong>也可以看作是一种<code>GC Roots</code>。<strong>总结下来就是，只要你的对象被方法的局部变量或是类的静态变量引用了，就不能回收它。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此我们知道回收和引 用有关，Java中有四种引用类型，它们分别是：<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>，针对不同的引用类型又有不同的回收策略：</p><ul><li><p><code>强引用</code>：一个变量引用一个对象。<strong>只要是强引用，垃圾回收时绝对不会去回收这个对象。</strong></p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><code>软引用</code>：通过<code>SoftReference</code>软引用类型把<code>ReplicaManager</code>类的对象直接包裹起来，这时候<code>replicaManager</code>对<code>ReplicaManager</code>类的对象就是软引用。<strong>正常垃圾回收不会回收软引用对象，只有当垃圾回收之后，发现内存还是不够存放新对象时，内存要溢出时，才会去回收软引用的对象。</strong></p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SoftReference<span class="token operator">&lt;</span>ReplicaManager<span class="token operator">></span> replicaManager <span class="token operator">=</span>             <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><code>弱引用</code>：通过<code>WeakReference</code>软引用类型把<code>ReplicaManager</code>类的对象直接包裹起来，这样静态变量持有的<code>ReplicaManager</code>类对象就是弱引用的了。<strong>弱引用就跟没有一样，垃圾回收直接回收掉。</strong></p></li><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> WeakReference<span class="token operator">&lt;</span>ReplicaManager<span class="token operator">></span> replicaManager <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><code>虚引用</code>：很少使用</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>总结</strong>：有<code>GC Roots</code>引用的对象不能回收，没有引用的可以回收，强引用不能回收，对于软引用，如果回收后内存依旧不够放入新的对象，就回收软引用的对象了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果我们不想没有GC Roots的对象立即被回收，我们可与使用重写Object的<code>finalize()</code>方法来拯救一下，这东西很少用，知道一下即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有下面这么一段代码，ReplicaFetcher的对象会被回收掉嘛？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReplicaManager</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ReplicaFetcher replicaFetcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaFetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;肯定是不会的，<code>ReplicaFetcher</code>类的对象被<code>ReplicaManager</code>类的<code>replicaFetcher</code>强引用着，而<code>ReplicaManager</code>类的对象被可作为GC Root的静态变量<code>replicaManager</code>强引用着，所以<code>ReplicaFetcher</code>对象可以向上找到GC Root，因此不会被回收。</p><h2 id="二、针对新生代的垃圾回收算法——复制算法"><a href="#二、针对新生代的垃圾回收算法——复制算法" class="headerlink" title="二、针对新生代的垃圾回收算法——复制算法"></a>二、针对新生代的垃圾回收算法——复制算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;背景：对于新生代，一种不太好的垃圾回收思路是直接对新生代里的垃圾对象进行标记，然后直接对垃圾进行回收，这样的缺陷是引入了许多内存碎片，内存碎片导致了内存的浪费，我们没有了完整的连续的内存空间是很难受的一件事。在这改进一下，我们可以将新生代内存空间划分为两部分，对<strong>不回收</strong>的对象进行标记，转移到另一块区域中顺便整理下，然后把另一块区域里的垃圾干掉，这就是所谓的复制算法。如下图</p><p><img src="https://img-blog.csdnimg.cn/2020020816594853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-om5GRGa0-1581152304198)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023185617356.png)\]"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么标记不回收的呢？因为新生代里存放的对象大都是存活时间很短的，所以不回收的只是很少一部分，标记速度更快，如果标记回收的，就不合适了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是复制算法有缺点，因为我们永远只有一半内存可以使用，另一半放垃圾，这样转移，使得内存使用效率太低了。所以对复制算法进行了优化。因为新生代放的都是存活时期非常短的对象，极端情况比如99%的垃圾1%有用的。实际上新生代内存区被划分为三部分：1块<code>Eden</code>区，2块<code>Survivor</code>区。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始对象都是优先被分配在<code>Eden</code>区的，如果<code>Eden</code>区快满了就触发<code>Minor GC</code>，把<code>Eden</code>中存活的对象全部转移到空的<code>Survivor</code>区，接着清空<code>Eden</code>中的垃圾，再次配分对象到<code>Eden</code>。由于存活的对象较少，所以给Survivor区域分配的内存就较少，当然看实际场景来分配。</p><p><img src="https://img-blog.csdnimg.cn/20200208170027214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DCS5LOUV-1581152304199)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023190409235.png)\]"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果<code>Survivor</code>一个区域中都放满了，并且<code>Eden</code>区域中也占满了，但是垃圾回收后可能就只有10M对象活着，只要把那10MB对象转移到另一块<code>Survivor</code>区域中即可，之后把第一块<code>Survivor</code>区域和<code>Eden</code>区域中垃圾全部回收，这样始终保证着有一块<code>Survivor</code>区域是空的。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200208170047902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CYhaAy18-1581152304200)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023190838996.png)\]"></p><h2 id="三、针对老年代的垃圾回收算法——标记整理算法"><a href="#三、针对老年代的垃圾回收算法——标记整理算法" class="headerlink" title="三、针对老年代的垃圾回收算法——标记整理算法"></a>三、针对老年代的垃圾回收算法——标记整理算法</h2><h3 id="1、进入老年代的几种情况"><a href="#1、进入老年代的几种情况" class="headerlink" title="1、进入老年代的几种情况"></a>1、进入老年代的几种情况</h3><h4 id="（1）躲过15次GC（当然我们可以自己设置次数）"><a href="#（1）躲过15次GC（当然我们可以自己设置次数）" class="headerlink" title="（1）躲过15次GC（当然我们可以自己设置次数）"></a>（1）躲过15次GC（当然我们可以自己设置次数）</h4><h4 id="（2）大对象直接进入老年代"><a href="#（2）大对象直接进入老年代" class="headerlink" title="（2）大对象直接进入老年代"></a>（2）大对象直接进入老年代</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过<code>-XX:PretenureSizeThreshold</code>把值设置成字节数，创建的对象大于这个值就直接进入老年代，之所以这么做是避免新生代里的大对象屡次躲过GC还要在三个区域来回复制，耗费时间。</p><h4 id="（3）动态对象年龄判断"><a href="#（3）动态对象年龄判断" class="headerlink" title="（3）动态对象年龄判断"></a>（3）动态对象年龄判断</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如当前放对象的Survivor区域里，一批对象的总大小，大于这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象就直接进入老年代</p><ul><li>假设100MB的Survivor中有俩对象，年龄都是2岁，但是俩对象加起来超过了50MB，也就是超过了一半了，这个时候，Survivor中大于等于2岁的对象都要进入老年代里去。<ul><li>避免动态年龄判断的方式：如果新生代内存有限，可以调整<code>-XX:SurvivorRatio=8</code>这个参数，默认是说Eden区比例为80%，也可以降低Eden区的比例，给两块Survivor区更多的内存空间，然后让每次Minor GC后的对象进入Survivor区中，还可以避免动态年龄判定规则直接把他们升入老年代。</li></ul></li></ul><h4 id="（4）空间分配担保规则"><a href="#（4）空间分配担保规则" class="headerlink" title="（4）空间分配担保规则"></a>（4）空间分配担保规则</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minor GC后发现对象太多，放不进Survivor区，就必须直接转移到老年代区的情况。<strong>在执行任何一次<code>Micro GC</code>前，JVM都会检查老年代的可用空间是否大于新生代所有对象的总大小</strong>，记住，是<strong>新生代所有对象总大小</strong>，因为极端情况下新生代可能所有对象都活下来了。下面就有两种情况了。</p><ul><li><strong>第一种情况</strong>：老年代剩余内存大小大于新生代所有对象总大小，放心<code>Minor GC</code>吧！即使你的Survivor区域放不下也可以放老年代去；</li><li><strong>第二种情况：</strong>老年代剩余内存大小小于新生代所有对象总大小，此时就会看<code>-XX:HandlePromotionFailure</code>参数是否设置了，若设置了，则会看老年代可用内存大小是否大于<strong>之前每一次Minor GC后进入老年代的对象的平均大小</strong>，如果不是，只能<code>Full GC</code>,即对老年代里的对象进行回收，才能让剩余存活对象进入老年代。如果是，则可以冒险尝试下<code>Minor GC</code>，但这个尝试也是有三种可能：<br>&emsp;<strong>可能一：</strong><code>Minor GC</code>后，剩余存活对象比<code>Survivor</code>区还小，就直接放进<code>Survivor</code>中<br>&emsp;<strong>可能二：</strong><code>Minor GC</code>后，剩余存活对象大于<code>Survivor</code>区，小于老年代可用区，即直接进入老年代<br>&emsp;<strong>可能三：</strong><code>Minor GC</code>后，剩余存活对象大于老年代可用区，放不下了，这时候就会触发<code>Full GC</code>，要是<code>Full GC</code>后还是放不下，直接导致<code>OOM内存溢出</code>。</li></ul><p>&emsp;&emsp;<strong>简介：空间担保机制是看老年代可用空间是否大于新生代所有对象总大小的，如果成立了，那么Minor GC就是安全的，如果不成立，则看<code>HandlerPromotionFailure</code>是否设置为true，true则允许担保失败，如果允许，则检查老年代可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试Minor GC，如果小于，则Full GC。<br>&emsp;&emsp;实际上<code>-XX:HandlePromotionFailure</code>参数在JDK 1.6以后就被废弃了，所以现在一般都不会在生产环境里设置这个参数了。JDK 1.6之前是把空间担保机制和<code>HandlerPromotionFailure</code>参数拆开了，JDK 1.6之后的空间担保机制只要满足”老年代可用连续空间 &gt; 新生代对象总大小或历次晋升到老年代对象的平均大小”其中一个就可，不满足就Full GC。</strong></p><p><img src="https://img-blog.csdnimg.cn/2020020817021856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="- \[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ExOzTU0w-1581152304201)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023194318928.png)\]"></p><h3 id="2、老年代Full-GC算法——标记整理算法"><a href="#2、老年代Full-GC算法——标记整理算法" class="headerlink" title="2、老年代Full GC算法——标记整理算法"></a>2、老年代Full GC算法——标记整理算法</h3><p>&emsp;&emsp;顾名思义，标记整理就是把老年代里活着的对象整理，紧凑在一起，避免垃圾回收后出现内存碎片。注意<code>Full GC</code>的速度比<code>Minor GC</code>慢10多倍，如果频繁出现<code>Full GC</code>就影响了系统性能，出现卡顿，但是你多两次<code>Minor GC</code>无关紧要，反正速度很快。</p><p>&emsp;&emsp;所以，所谓JVM优化，就是尽量能让对象在新生代里进行分配和回收，别让太多对象进入老年代，避免对老年代的频繁<code>Full GC</code>，同时要给系统足够的内存大小来避免新生代频繁的<code>Minor GC</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200208170242625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xJsW6N3p-1581152304202)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023194609145.png)\]"></p><p>未回收前</p><p><img src="https://img-blog.csdnimg.cn/20200208170301143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NSYGdfm1-1581152304203)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023194646277.png)\]"></p><p>回收后</p><p><strong>为什么老年代不用复制算法？</strong></p><p>&emsp;&emsp;因为老年代存活的对象太多了，如果用复制算法，每次挪动90%的对象很不方便，所以采用标记回收，把有用的挪到一边，然后回收垃圾，是很好的一个方式。</p><h3 id="3、针对第三节面试会问的问题"><a href="#3、针对第三节面试会问的问题" class="headerlink" title="3、针对第三节面试会问的问题"></a>3、针对第三节面试会问的问题</h3><pre><code>(1)、什么时候会尝试触发Minor GC？ 答：当新生代的Eden区和其中一个Survivor区空间不足时。(2)、什么时候会尝试触发Full GC？答：第一是老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；第二是老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；第三是新生代Minor GC后的存活对象大于Survivor，那么就会进入老年代，此时老年代内存不足，就要Full GC；第四是是“-XX:CMSInitiatingOccupancyFaction”参数的设置，当老年代中的对象到达这个比例时就会GC；（老年代可用内存大于历次新生代GC后进入老年代的对象平均大小，但是老年代已经使用的内存空间超过了这个参数指定的比例，也会自动触发Full GC）(3)、触发Minor GC之前会如何检查老年代大小，涉及哪几个步骤和条件？ 答：1、先判断新生代中所有对象的大小是否 小于 老年代的可用区域 true 则 触发Minor GC，false则继续进行下面2中的判断 2、如果设置了-XX:HandlePromotionFailure这个参数，那么进入第3步 如果没有设置-XX:HandlePromotionFailure参数，那么触发Full GC (4)、什么时候在Minor GC之前就会提前触发一次Full GC？ 答：当判断 新生代历次进入老年代对象的平均大小 大于 老年代的可用区域就会触发一次Full GC，让老年代腾出一些空间，腾出空间后再进行Minor GC。 (5)、Minor GC过后可能对应哪几种情况？ 答： 情况1：Minor GC前先判断：存活的对象所占的内存空间 &lt; Survivor区域内存空间的大小，那么存活的对象进入Survivor区。 情况2：Minor GC前先判断：Survivor区域内存空间的大小 &lt; 存活的对象所占的内存空间 &lt; 老年代的可用空间大小。那么存活的对象，直接进入老年代。 情况3：Minor GC前先判断： (存活的对象所占的内存空间 &gt; Survivor区域内存空间的大小) &amp;&amp; (存活的对象所占的内存空间 &gt; 老年代的可用空间大小)。那么会触发Full GC，老年代腾出空间后，再进行Minor GC。如果腾出空间后还不能存放存活的对象，那么会导致OOM即堆内存空间不足、堆内存溢出。 </code></pre><h2 id="四、垃圾回收容器简介"><a href="#四、垃圾回收容器简介" class="headerlink" title="四、垃圾回收容器简介"></a>四、垃圾回收容器简介</h2><h3 id="1、抛出问题：垃圾回收的同时能创建对象吗？"><a href="#1、抛出问题：垃圾回收的同时能创建对象吗？" class="headerlink" title="1、抛出问题：垃圾回收的同时能创建对象吗？"></a>1、抛出问题：垃圾回收的同时能创建对象吗？</h3><p>&emsp;&emsp;<strong>不能</strong>！垃圾回收的时候，尽可能要让垃圾收集器专心工作，此时JVM在后台直接进入<code>Stop the World</code>状态，停止我们写的Java系统的所有线程，让我们代码不再运行。一旦回收完毕，就可以恢复线程运行了。这里要注意的就是避免频繁GC，无论是新生代还是老年代，我们都不希望系统隔一段时间卡死一下，这是JVM最需要优化的地方。当然我们可以使用适当的垃圾回收容器来缩短回收的时间。</p><p><img src="https://img-blog.csdnimg.cn/20200208170342848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6DsEndCV-1581152304204)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023201603168.png)\]"></p><h3 id="2、垃圾回收容器"><a href="#2、垃圾回收容器" class="headerlink" title="2、垃圾回收容器"></a>2、垃圾回收容器</h3><p>&emsp;&emsp;不同的内存区域使用不同的垃圾回收容器，简单介绍下垃圾回收容器</p><ul><li><p><code>Serial和Serial Old</code>：分别用来回收新生代和老年代对象。工作原理就是单线程运行，回收的时候会停止系统中其他工作线程，现在几乎不用。</p></li><li><p><code>ParNew和CMS</code>：<code>ParNew</code>是用在新生代的回收容器，<code>CMS</code>是用在老年代的回收容器，他们都是多线程并发机制，性能较好，一般是线上系统标配组合。</p></li><li><p><code>G1</code>：统一收集新生代和老年代，采用了更优秀的算法和设计机制</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200208170407341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>多线程回收</p><h2 id="五、捋清概念"><a href="#五、捋清概念" class="headerlink" title="五、捋清概念"></a>五、捋清概念</h2><p>&emsp;&emsp;有很多GC名词需要捋一下：Minor GC、Young GC、Full GC、Old GC、Major GC、Mixed GC。</p><h3 id="1、Minor-GC-与Young-GC"><a href="#1、Minor-GC-与Young-GC" class="headerlink" title="1、Minor GC 与Young GC"></a>1、Minor GC 与Young GC</h3><p>&emsp;&emsp;年轻代 = 新生代，新生代的回收就叫Minor GC或是Young GC</p><h3 id="2、Full-GC与Old-GC"><a href="#2、Full-GC与Old-GC" class="headerlink" title="2、Full GC与Old GC"></a>2、Full GC与Old GC</h3><p>&emsp;&emsp;Full GC就是整体的意思，指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为Full GC，但是说实话，平时习惯就是把Full GC等价为Old GC，也就是仅仅针对老年代的垃圾回收。</p><h3 id="3、Major-GC"><a href="#3、Major-GC" class="headerlink" title="3、Major GC"></a>3、Major GC</h3><p>&emsp;&emsp;有些人把Major GC跟Old GC等价起来，认为他就是针对老年代的GC，也有人把Major GC和Full GC等价起来，认为他是针对JVM全体内存区域的GC。这个概念少提，如果提了，就要问清楚你到底针对整体还是针对老年代。</p><h3 id="4、Mixed-GC"><a href="#4、Mixed-GC" class="headerlink" title="4、Mixed GC"></a>4、Mixed GC</h3><p>&emsp;&emsp;G1中的一个垃圾回收机制，一旦老年代占据堆内存的45%了，就要触发Mixed GC，此时对年轻代和老年代都会进行回收。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/22/JVM%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/08/22/JVM%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM学习笔记（2）：JVM分代模型与内存参数设置"><a href="#JVM学习笔记（2）：JVM分代模型与内存参数设置" class="headerlink" title="JVM学习笔记（2）：JVM分代模型与内存参数设置"></a>JVM学习笔记（2）：JVM分代模型与内存参数设置</h1><h2 id="一、JVM分代模型"><a href="#一、JVM分代模型" class="headerlink" title="一、JVM分代模型"></a>一、JVM分代模型</h2><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 年轻代</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        replicaManager<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到在<code>main()</code>方法的<code>while</code>循环中，不断调用<code>loadReplicasFromDisk()</code>方法生成新对象，这个新生成对象的存活时间是极其短的，大致过程是<code>loadReplicasFromDisk()</code>入栈，在堆内存中生成对象，栈帧里的局部变量指向这个对象，然后方法结束，出栈，这个对象就没人指向了，结果如下图</p><p><img src="https://img-blog.csdnimg.cn/20200208164956800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qvSQRQe8-1581151768943)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023122908214.png)\]"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但有些对象是长期存活的，比如下面这段代码。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 老年代</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        replicaManager<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Kafka类中定一个一个<strong>静态</strong>变量，这个静态变量指向堆内存中的对象，while循环中不停得调用这个对象的方法，使得这个对象一直被引用，这样就长期存活下来了。<br><img src="https://img-blog.csdnimg.cn/20200208165021425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、年轻代、老年代、永久代"><a href="#2、年轻代、老年代、永久代" class="headerlink" title="2、年轻代、老年代、永久代"></a>2、年轻代、老年代、永久代</h3><ul><li><p>JVM将Java堆内存分成两个区域，即年轻代和老年代，年轻代就是生命周期极短、用完就要被回收的对象所在的区域，老年代就是生命周期较长对象存在的区域，需要一直存在堆中，让程序后续不断的去使用。</p></li><li><p>为什么要设计两个区域呢？因为针对每个对象的生命周期特点来设计不同的GC算法，保证GC的稳定性。</p></li><li><p>永久代：之前讲过的<strong>方法区</strong>就是永久代，它存放了类相关的信息</p></li><li><p>永久代会产生回收嘛？肯定是会的，有这样几种情况会导致回收</p><ul><li>该类在堆中的<strong>所有实例对象</strong>都被回收了</li><li>加载这个<strong>类的ClassLoader</strong>也被回收了（比如自己定义的类加载器也是个对象，没人用就会被回收）</li><li>最后对该<strong>类的Class对象</strong>也没有引用（如果有变量引用类的Class对象，就是有引用）<ul><li>比如利用反射，来获取一个对象的类的Class对象实例，如<code>Class c = replicaManager.getClass()</code>，可以通过<code>replicaManager</code>引用的对象来获取<code>ReplicaManager</code>类的Class对象，这个变量<code>c</code>就能引用这个Class对象</li></ul></li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReplicaFetcher fetcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaFetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//年轻代</span>        <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//老年代</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">loadReplicasFromRemote</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        replicaManager<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadReplicasFromRemote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fetcher<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对应下面这张图</p><p><img src="https://img-blog.csdnimg.cn/20200208165107551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dmwze3Ei-1581151768946)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023123613648.png)\]"></p><h2 id="二、JVM内存如何分配？"><a href="#二、JVM内存如何分配？" class="headerlink" title="二、JVM内存如何分配？"></a>二、JVM内存如何分配？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然有了年轻代和老年代，但是对于大部分正常对象，都是先升在新生代中分配内存的，新生代就是年轻代和老年代的总和，一开始并没有区分。我们的对象有两种类型，一种是像ReplicaManager这样的，用完一次就没人指向他了，这样的对象在新生代内存中不断囤积，最后导致空间几乎都被它占满了，那就会触发<code>Minor GC</code>，又称之为<code>Young GC</code>，它就把新生代中的没用的这些垃圾回收掉；另一种对象是像ReplicaFetcher这样的，始终有人指向它，JVM中有规定，垃圾每回收一次，如果一个对象没被回收掉，它的年龄就增加1，如果一个对象年龄超过15，就会把它放置到老年代区域（这个阈值我们可以修改，默认值是15），也就是说老年代存放了年龄很大的对象，下面两张图就很形象。同样的，如果老年代也满了也会被回收。</p><p>小结：</p><ul><li>一般对象先分在新生代，新生代满了就GC，有些对象满足条件进入老年代，老年代满了也会GC，清除没用的</li></ul><p>对象分配的机制有很多，如</p><ul><li>Minor GC后存活对象太多，大量对象直接进入老年代</li><li>超大对象不经新生代直接进入老年代</li><li>动态对象年龄判断机制</li><li>空间担保机制</li></ul><p><img src="https://img-blog.csdnimg.cn/20200208165142923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cJvOeVH7-1581151768946)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023124904312.png)\]"></p><p>ReplicaManager的对象太多导致内存不够</p><p><img src="https://img-blog.csdnimg.cn/20200208165157693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fpMpgXhH-1581151768947)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023125106799.png)\]"></p><p>ReplicaManager的对象被回收掉，且ReplicaFetcher对象符合要求进入老年代</p><h2 id="三、JVM内存分配参数"><a href="#三、JVM内存分配参数" class="headerlink" title="三、JVM内存分配参数"></a>三、JVM内存分配参数</h2><pre><code>-Xms：Java堆内存大小-Xmx：Java堆内存最大大小-Xmn：Java堆内存中新生代大小，扣除新生代就是老年代的大小了-XX:PermSize：永久代大小-XX:MaxPermSize：永久代最大大小-Xss：每个线程栈内大小，一般0.5～1M</code></pre><p><img src="https://img-blog.csdnimg.cn/20200208165314502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dToftfvg-1581151768948)(JVM（2）：JVM内存概念.assets/image-20200208164533019.png)\]"></p><h2 id="四、JVM堆内存、栈内存、永久代大小设置"><a href="#四、JVM堆内存、栈内存、永久代大小设置" class="headerlink" title="四、JVM堆内存、栈内存、永久代大小设置"></a>四、JVM堆内存、栈内存、永久代大小设置</h2><h3 id="1、堆内存大小设置"><a href="#1、堆内存大小设置" class="headerlink" title="1、堆内存大小设置"></a>1、堆内存大小设置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;背景是电商支付系统，首先看一下支付流程：</p><p><img src="https://img-blog.csdnimg.cn/20200208165252614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EsN9NWEC-1581151768949)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023130403198.png)\]"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个系统的支付压力就是每日百万订单的交易，从JVM角度来看，就是在堆内存中生存了百万个订单对象，而这些订单频繁的创建和销毁就是核心问题。</p><p><img src="https://img-blog.csdnimg.cn/2020020816533083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-K7YlCRAX-1581151768949)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023130619932.png)\]"></p><p>我们怎么去设定堆内存的大小呢？按照下边的步骤估计：</p><ul><li>确定业务规模，分析系统压力点</li><li>确定我们的系统部署了多少台机器，计算每秒请求数，考虑每个请求的耗时</li><li>结合每个请求消耗的内存，确定机器的参数，分配多少内存空间合适</li><li>确定每台机器JVM分配的内存空间（方法区、栈内存、堆内存，堆中新生代、老年代大小）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们一天100万个订单，共三台机器，把这100w个订单分配到几个小时里（考虑高峰时间段），假设算下来一秒钟100个订单。把这100个订单的任务分配个3台机器，每台机器一秒30个订单，那这30个订单占多少内存？就要看我们订单对象是多大了，看订单对象里面的变量来计算（Integer变量4字节，Long类型8字节…），假设1kb，那么30个订单也就30kb，大概情况如下。系统运行起来后，一台机器每秒有30个对象不被使用了，然后直到新生代空间快满了，就发生一次Minor GC，这就是这个业务运行的模型。但是实际情况下，每秒钟创建出来的对象不单单就订单对象，还会创建许多其他对象，所以每秒创建出来的被栈内存中局部变量引用的对象所占用的空间大致在几百KB～1MB之间。</p><p><img src="https://img-blog.csdnimg.cn/20200208165343454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fjnoYtE2-1581151768950)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023131605730.png)\]"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做完了前三步后，我们要估算JVM堆内存如何分配了，常见的机器配置也就2核4G或4核8G。以2核4G为例，一半内存要给机器本身运行，另一半分配给JVM，也就是说分配到了2G，这2G要分配给方法区、栈内存、堆内存，堆内存最多再分得一半，也就是1G，堆内存中要划分新生代和老年代，假设都给一半，实际业务情况下1秒占1M那么过不了多了就会GC，频繁的GC影响了系统的稳定性，所以不行，还是得换4核8G，这样堆内存还能分得多一点，比如分3G（-Xms和-Xmx设置为3G，整个堆内存，然后-Xmn给新生代2G），能够大大降低GC频率，当然部署机器越多，对JVM压力更小。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们设置内存过小会出现什么情况？比如双十一，这会每秒支付不再是1秒100个了，而是秒1000个，这时候所有资源都会吃紧，当然有些支付请求并不是立即支付的，它可能卡好久，使得这些数据在Minor GC后都放到了老年代，与此同时新生代中又不断增加对象，最后新生代又爆满，然后再Minor GC放到老年代。。。最后老年代对象越来越多，可能频繁触发老年代的垃圾回收，<strong>老年代的垃圾回收速度是很慢的！</strong>，然后不断影响系统性能</p><p><img src="https://img-blog.csdnimg.cn/20200208165359339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQyNDY2OA==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0qpcSbjJ-1581151768950)(/Users/zhangye/Library/Application Support/typora-user-images/image-20191023133653816.png)\]"></p><h3 id="2、栈内存和永久代大小设置"><a href="#2、栈内存和永久代大小设置" class="headerlink" title="2、栈内存和永久代大小设置"></a>2、栈内存和永久代大小设置</h3><p>栈内存：不用特别的去估计和设置，默认的是<strong>512KB～1MB</strong>，差不多够了。</p><p>永久代：存放类相关信息，一般设置<strong>几百MB</strong>是够的，当然有些系统会导致永久代内存溢出，后面分析。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2019/08/21/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/08/21/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM学习笔记"><a href="#JVM学习笔记" class="headerlink" title="JVM学习笔记"></a>JVM学习笔记</h1><h2 id="一、初识JVM"><a href="#一、初识JVM" class="headerlink" title="一、初识JVM"></a>一、初识JVM</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们写好一份Java代码，要将其部署到线上的机器去运行，就要将其打包成<code>.jar</code>或<code>.war</code>后缀的包，再进行部署。其中关键的一步是<strong>编译</strong>，也就是要把<code>.java</code>文件编译成<code>.class</code>字节码文件，有了字节码文件可以通过java命令来启动一个<code>JVM</code>进程，由JVM来负责运行这些字节码文件。所以说，在某个机器上部署某个系统后，一旦启动这个系统，实际上就是启动了<code>JVM</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们写好了一个个类是通过<code>类加载器</code>把字节码文件加载到JVM中的，JVM会首先从<code>main()</code>方法开始执行里面的代码，它需要哪个类就会使用类加载器来加载对应的类，反正对应的类就在<code>.class</code>文件中。</p><p><strong>注意</strong>：如果一个项目中有多个<code>main()</code>方法，在启动一个jar包的时候，就制定了是走哪个<code>main()</code>方法，所以入口是唯一的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmRwb244ajMxMnMwcnNnbmcuanBn?x-oss-process=image/format,png" alt="image-20191022200133521"></p><p>程序运行机制</p><h2 id="二、初识JVM类加载器机制"><a href="#二、初识JVM类加载器机制" class="headerlink" title="二、初识JVM类加载器机制"></a>二、初识JVM类加载器机制</h2><h3 id="2-1引入"><a href="#2-1引入" class="headerlink" title="2.1引入"></a>2.1引入</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题：JVM什么时候会加载一个类？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单的例子是直接从<code>main()</code>进入开始执行，比如</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmZsb2U5ajMwZGkwYXFxMzMuanBn?x-oss-process=image/format,png" alt="image-20191022200843705"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果碰到了实例化对象的操作，才把实例化的这个类的<code>.class</code>文件加载到内存（之前是没有加载进来的）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmJkamxwajMwa3MwYmNqcnUuanBn?x-oss-process=image/format,png" alt="image-20191022200930890"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是包含<code>main()</code>方法的主类会在JVM启动之后首先被加载到内存中，然后开始执行<code>main()</code>中的代码，碰到需要使用的类，才去加载这个类对应的字节码文件，也就是说是按需加载。</p><h3 id="2-2类加载过程"><a href="#2-2类加载过程" class="headerlink" title="2.2类加载过程"></a>2.2类加载过程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类加载的过程为：加载、验证、准备、解析、初始化、使用、卸载</p><ul><li><p><code>验证</code>：就是看字节码文件是否符合规范。</p></li><li><p><code>准备</code>：给类<strong>分配内存空间</strong>，其次为<code>类变量</code>分配内存空间，并设定一个默认值。<strong>不执行赋值！</strong></p></li><li><p><code>解析</code>：符号引用替换为直接引用的过程</p></li><li><p><code>初始化</code>：正式执行类初始化的代码，在这里才是执行赋值代码等操作，<code>准备阶段</code>仅仅为类和变量开辟空间。在这个阶段执行初始化操作有很多，比如对于静态代码块的初始化就是在这个阶段执行的（JVM设计者设计先执行静态代码块的机制是希望开发者把类使用之前的准备工作在这准备好类级别的数据）。要记住，类的初始化就是初始化这个类，和里头的对象无关，只有new关键字才会构造出一个对象。</p></li><li><p><strong>什么时候会初始化一个类呢？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说包含<code>main()</code>方法的类是必须立马初始化的，或者说执行到new对象了，就会把这个对象的类初始化，如果这个类初始化过了，就不用进行第二次初始化。初始化重要的一个规则是：<strong>初始化一个类的时候，如果该类的父类没有初始化，（如果父类也没有加载的话）必须先加载并初始化它的父类！</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReplicaManager</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractDataManager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//ReplicaManager继承AbstractDataManager，在初始化ReplicaManager时必须先初始化它的父类</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="2-3类加载器和双亲委派机制"><a href="#2-3类加载器和双亲委派机制" class="headerlink" title="2.3类加载器和双亲委派机制"></a>2.3类加载器和双亲委派机制</h3><p>1、Java中的类加载器</p><ul><li><code>启动类加载器</code>：负责加载机器上安装的Java目录下的核心类，Java安装目录下有个<code>lib</code>文件存放了Java的核心库，JVM启动后，首先会依托<code>启动类加载器</code>去加载lib。</li><li><code>扩展类加载器</code>：就是加载<code>lib/ext</code>目录，和启动类加载器差不多，但它是启动类加载器的儿子。</li><li><code>应用程序类加载器</code>：负责加载<code>ClassPath</code>环境变量指定路径中的类，就是把你写好的代码加载进内存。</li><li><code>自定义类加载器</code>：自己写的类加载器，继承<code>ClassLoader</code>类，重写类加载方法</li></ul><p>2、双亲委派机制</p><p>JVM的加载器是有亲子结构的，如图所示，提出了<strong>双亲委派机制</strong>。</p><p><code>双亲委派机制</code>：如果应用程序要加载一个类，首先会委派自己的父类加载器去加载，直至传到最顶层的加载器去加载，如果父类加载器在自己的职责范围内没有找到这个类，就会把加载权利下放给子类加载器。<strong>总的来说，就说先找父类去加载，不行再由儿子来加载</strong>。先从顶层加载器开始，发现自己加载不到，往下推给子类，这样能<strong>保证绝不会重复加载某个类</strong>。</p><p>双亲委派的好处：避免了类的重复加载，如果两个不同层级的类加载器可以加载同一个类，就重复了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmU3ajJiajMwZW8waG1qcnouanBn?x-oss-process=image/format,png" alt="image-20191022203551092"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmc2eDF0ajMweDIwdTBhZ3EuanBn?x-oss-process=image/format,png" alt="image-20191022204250043"></p><h2 id="三、初识JVM内存区域"><a href="#三、初识JVM内存区域" class="headerlink" title="三、初识JVM内存区域"></a>三、初识JVM内存区域</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们写好的代码中有很多的类，类中有许多的方法，同时方法中也有许多变量，它们都需要放到合适的区域，这就是JVM为什么要划分出不同内存区域的原因，下面介绍下JVM中的内存区域分类。</p><h3 id="3-1存放类的区域——方法区"><a href="#3-1存放类的区域——方法区" class="headerlink" title="3.1存放类的区域——方法区"></a>3.1存放类的区域——方法区</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>方法区</code>主要存放从<code>class</code>文件中加载进来的类，JDK 1.8后这块区域改名为<code>Metaspace</code>，即元数据空间，放的还是我们自己写的各种类相关的信息。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们有上面这个例子，JVM首先类加载<code>Kafka.class</code>到方法区，当程序运行到实例化对象那句，就把<code>ReplicaManager.class</code>加载到方法区。如果<code>Kafka</code>类中有静态变量，也一样会进入方法区。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmVvZGkwajMwczYwZjgzem8uanBn?x-oss-process=image/format,png" alt="image-20191022205633246"></p><h3 id="3-2程序计数器——执行代码指令用的"><a href="#3-2程序计数器——执行代码指令用的" class="headerlink" title="3.2程序计数器——执行代码指令用的"></a>3.2程序计数器——执行代码指令用的</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们写好的Java文件被编译成.class文件后就应对成了一行行的字节码指令，JVM加载类信息到方法区后，会去执行编译出来的字节码指令，执行的时候用到了<code>程序计数器</code>，它用来记录我们的程序执行到了哪一行字节码指令。由于JVM是支持多线程的，如果写好的代码开启了多个线程，那么每个线程都会有对应的程序计数器，来表示当前线程执行到了哪一条指令。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmQ5aGU0ajMwejIwbTRkaHouanBn?x-oss-process=image/format,png" alt="image-20191022210127355"></p><h3 id="3-3存放方法的区域——Java虚拟机栈"><a href="#3-3存放方法的区域——Java虚拟机栈" class="headerlink" title="3.3存放方法的区域——Java虚拟机栈"></a>3.3存放方法的区域——Java虚拟机栈</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>main()</code>方法中有程序计数器来记录指令执行到哪了，但在方法中我们也会定义一些<code>局部变量</code>，JVM有一块区域是专门用来放<code>局部变量</code>的，即<code>Java虚拟机栈</code>，同样的，对于每个线程，它们有自己的<code>Java虚拟机栈</code>，如果一个线程执行了一个方法，会为这个方法调用创建一个对应的<code>栈帧</code>，<code>栈帧</code>中包含着局部变量表、操作数栈、动态链接、方法出口等。比如main线程执行了<code>main()</code>方法，那就为<code>main()</code>方法创建了一个<code>栈帧</code>，并将其压入了<code>Java虚拟机栈</code>，同时在<code>main()</code>方法的栈帧中也存放着它的局部变量。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmF3cWhmajMwYnkwNzhhYTguanBn?x-oss-process=image/format,png" alt="image-20191022210915396"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//含有main方法的Kafka类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Kafka</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReplicaManager replicaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReplicaManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        replicaManager<span class="token punctuation">.</span><span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReplicaManager</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadReplicasFromDisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Boolean hasFinishedLoad <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLocalDataCorrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Boolean <span class="token function">isLocalDataCorrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Boolean isCorrect <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> isCorrect<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如上面这段代码，对应的Java虚拟机栈如下。在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。如果<code>isLocalDataCorrupt</code>方法执行完毕了，就会把<code>isLocalDataCorrupt</code>方法对应的栈帧从Java虚拟机栈里给出栈，然后如果<code>loadReplicasFromDisk</code>方法也执行完毕了，就会把<code>loadReplicasFromDisk</code>方法也从Java虚拟机栈里出栈。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmNxb3MyajMwYnUwZWVteHYuanBn?x-oss-process=image/format,png" alt="image-20191022211302798"></p><h3 id="3-4存放对象的区域——Java内存堆"><a href="#3-4存放对象的区域——Java内存堆" class="headerlink" title="3.4存放对象的区域——Java内存堆"></a>3.4存放对象的区域——Java内存堆</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在main方法里创建了ReplicaManager对象的时候，就会在main方法对应的栈帧的局部变量表里，让一个引用类型的“replicaManager”局部变量来存放ReplicaManager对象的地址。</p><p><strong>注意：</strong></p><ul><li>新建的实例在堆内存，实例变量（对象变量）也是在堆内存的</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmYzZW93ajMwdmUwaDhqc3QuanBn?x-oss-process=image/format,png" alt="image-20191022211719538"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmFrZzl1ajMwdmEwbW03NmIuanBn?x-oss-process=image/format,png" alt="image-20191022211740061"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下这个过程：JVM进程启动后，首先会加载含有<code>main</code>方法的<code>Kafka</code>类到内存里（方法区），生成一个main线程，然后为这个线程分配一个程序计数器，开始执行程序。先生成main方法的栈帧，压入Java虚拟机栈，然后执行到<code>new ReplicaManager()</code>时，就会把<code>ReplicaManager</code>类加载进内存（方法区），接着发现要实例化一个对象，把这个对象的内存分配在Java内存堆中，并在main方法的栈帧里的局部变量表引入一个<code>replicaManager</code>局部变量，把它指向堆内存中的地址，然后main线程开始执行<code>ReplicaManager</code>对象中的方法依次把方法压栈，执行完出栈。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结：<strong>类都是加载到方法区里的，而且是按需加载，只加载一次，要new对象时候，对象被分配在堆汇总，执行方法时为这个方法生成栈栈压入虚拟机栈，然后对应变量指向堆内存中的地址，完成方法则出栈。</strong></p><h2 id="四、初识垃圾回收机制"><a href="#四、初识垃圾回收机制" class="headerlink" title="四、初识垃圾回收机制"></a>四、初识垃圾回收机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个方法执行完后的结果是怎样的？如图，也就是没有变量指向这个变量了，由于我们在内存堆里创建的对象都是占用内存资源的，所以需要回收它。JVM本身带有垃圾回收机制，它是<strong>后台自动运行的线程</strong>。它检索这个对象是否有人引用，如果没有任何人指向他，就会把这个对象给回收掉，从内存中清除。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndseTFnYWN1dmNib3R2ajMwejgwYmlhYXIuanBn?x-oss-process=image/format,png" alt="image-20191022212757368"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
